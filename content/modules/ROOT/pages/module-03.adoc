= Module 3: Deploying to edge locations
:page-nav-title: Deploy & Verify Appliance
:icons: font
:source-highlighter: rouge
:experimental:

== Learning objectives
By the end of this module, you will be able to:

* [x] Create an isolated network for disconnected environment simulation
* [x] Deploy a bootc image to a virtual machine using KVM
* [x] Configure kubeconfig for MicroShift access
* [x] Verify a self-contained appliance is running correctly
* [x] Confirm embedded container images are being used (not pulled from network)

[#know_section]
[#deploying]
== 3.1 Know: Deploying to Edge Locations

=== The Business Challenge
ManufacturingCo must deploy appliances to 50 factory locations with varying constraints.

[cols="1,2a", options="header"]
|===
| Constraint | Impact on Deployment
| **No Connectivity** | Standard "pull-based" cloud deployments will fail instantly.
| **Low Bandwidth** | Large image downloads would take days or disrupt factory operations.
| **Limited On-site IT** | The installation process must be "Zero Touch" and automated.
|===

**The Solution:** ISO-based deployment provides a single, portable file that contains the entire OS, MicroShift, and application stack.

=== ISO-Based Deployment vs. Traditional Methods

[cols="1a,1a", options="header"]
|===
| ❌ Traditional Network-Dependent | ✅ bootc ISO (Disconnected)
| 
* Requires internet to pull packages/images.
* Fragile: Installation fails if network drops.
* Configuration drift across different sites.
| 
* **Self-Contained:** Everything is inside the ISO.
* **Resilient:** Works via USB or local PXE boot.
* **Atomic:** Identical installation at every site.
|===

[#show_section]
[#boot_vm]
== 3.2 Show: Deploy the Appliance to Target System

=== The Deployment Workflow
We are simulating an **offline factory** by creating an isolated virtual network before installing the ISO.

KVM is the Linux virtualization system used to run the VM. Kickstart is an automated installer file.

[cols="^1,2,2", options="header"]
|===
| Step | Action | Purpose
| 1 | **Isolate Network** | Simulate a factory with no internet access.
| 2 | **Define VM** | Prepare the target hardware (simulated via KVM).
| 3 | **Automate Install** | Use Kickstart to install the image with zero manual clicks.
|===

=== 1. Create Isolated Network
. View the setup script:
+
[source,sh,role=execute]
----
cat setup-isolated-net.sh
----
+
[%collapsible]
====
.Output of `setup-isolated-net.sh`
[source,bash]
----
#!/bin/bash
#
# Script to create an isolated KVM network (no internet access)
# and optionally attach a VM to it
#

set -e

# Configuration
NETWORK_NAME="bootc-isolated"
BRIDGE_NAME="virbr-bootc"
NETWORK_IP="192.168.100.1"
NETWORK_NETMASK="255.255.255.0"
NETWORK_RANGE_START="192.168.100.2"
NETWORK_RANGE_END="192.168.100.254"
NETWORK_XML="/tmp/${NETWORK_NAME}.xml"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running as root or with sudo
if [ "$EUID" -ne 0 ]; then 
    print_error "Please run as root or with sudo"
    exit 1
fi

# Check if network already exists (defined or active)
if virsh net-info "${NETWORK_NAME}" &>/dev/null || virsh net-list --all --name | grep -q "^${NETWORK_NAME}$"; then
    print_warn "Network '${NETWORK_NAME}' already exists"
    read -p "Do you want to destroy and recreate it? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        print_info "Destroying existing network..."
        # Try to destroy if active
        if virsh net-destroy "${NETWORK_NAME}" &>/dev/null; then
            print_info "Network destroyed"
        fi
        # Undefine the network
        if virsh net-undefine "${NETWORK_NAME}" &>/dev/null; then
            print_info "Network undefined"
        fi
    else
        print_info "Exiting without changes"
        exit 0
    fi
fi

# Create network XML file
print_info "Creating isolated network XML definition..."
cat > "${NETWORK_XML}" <<EOF
<network>
  <name>${NETWORK_NAME}</name>
  <uuid>$(uuidgen)</uuid>
  <forward mode='none'/>
  <bridge name='${BRIDGE_NAME}' stp='on' delay='0'/>
  <ip address='${NETWORK_IP}' netmask='${NETWORK_NETMASK}'>
    <dhcp>
      <range start='${NETWORK_RANGE_START}' end='${NETWORK_RANGE_END}'/>
    </dhcp>
  </ip>
</network>
EOF

print_info "Network XML created at ${NETWORK_XML}"

# Define the network
print_info "Defining network '${NETWORK_NAME}'..."
virsh net-define "${NETWORK_XML}"

# Start the network
print_info "Starting network '${NETWORK_NAME}'..."
virsh net-start "${NETWORK_NAME}"

# Set network to autostart
print_info "Setting network '${NETWORK_NAME}' to autostart..."
virsh net-autostart "${NETWORK_NAME}"

# Verify network is active
if virsh net-info "${NETWORK_NAME}" | grep -q "Active:.*yes"; then
    print_info "Network '${NETWORK_NAME}' is now active and isolated (no internet access)"
    print_info "Network details:"
    virsh net-info "${NETWORK_NAME}"
    echo
    print_info "Network IP range: ${NETWORK_RANGE_START} - ${NETWORK_RANGE_END}"
    print_info "Gateway/DNS: ${NETWORK_IP}"
else
    print_error "Failed to start network"
    exit 1
fi

# Clean up temporary XML file
rm -f "${NETWORK_XML}"

print_info "Isolated network setup complete!"
print_info "To use this network in create-vm.sh, set NETNAME='${NETWORK_NAME}'"
----
====

. Create the network:
+
[source,sh,role=execute]
----
sudo bash setup-isolate-net.sh
----
+
**What this does:**

- Creates a libvirt virtual network named `bootc-isolated`
- Configures network isolation for the MicroShift VM
- Sets up necessary network bridges for VM communication
+
**Expected output:**

- Network `bootc-isolated` is created and active
- Ready for VM deployment


=== 2. Create and Boot the VM

. Resize and move the disk image:
+
[source,sh,role=execute]
----
sudo qemu-img resize ./output/qcow2/disk.qcow2 +30G
sudo mv ./output/qcow2/disk.qcow2 /var/lib/libvirt/images/microshift-workshop-4.21.qcow2
----

. Create VM using virt-install:
+
[source,sh,role=execute]
----
sudo virt-install \
  --name microshift-workshop \
  --vcpus 2 \
  --memory 4096 \
  --disk path=/var/lib/libvirt/images/microshift-workshop-4.21.qcow2,format=qcow2 \
  --network network=bootc-isolated,model=virtio \
  --import \
  --os-variant centos-stream9 \
  --graphics none \
  --noautoconsole
----

[TIP]
.Architecture Insight: Kickstart & bootc
====
The Kickstart file uses the `ostreecontainer` command to tell the installer to pull the OS directly from the local OCI archive embedded on the ISO, rather than a remote registry.
====

=== 3. Verify VM Status
[source,sh,role=execute]
----
sudo virsh list --all
----

[#verify_disconnected]
== 3.3 Show: Verify Disconnected Operation

=== Connectivity & Access
Now we prove the appliance functions without any external network reach.

. Find the IP address of the VM:
+
[source,sh,role=execute]
----
watch sudo virsh domifaddr microshift-workshop
----
+
The output will show the IP address assigned to the VM. Note the IP address (for example, `192.168.100.165`).

. Once we see the ip assigned to the VM. CTRL+C exit the watch.

. Connect to the VM via SSH using the IP address:
+
[source,sh,role=execute]
----
ssh centos@<VM_IP_ADDRESS>
----
+
When prompted, enter the password: `bootc`
+
[NOTE]
====
The default user is `centos` with password `bootc`. You should see a message indicating "Boot Status is GREEN - Health Check SUCCESS" when you successfully connect.
====

. Check system health:
+
[source,sh,role=execute]
----
sudo bootc status
----

# Verify OS version changed to CentOS 10
[source,sh,role=execute]
----
cat /etc/os-release
----

. Check MicroShift service status:
+
[source,sh,role=execute]
----
sudo systemctl status microshift-embed
----

+
[NOTE]
====
Take a look at the service status. It is importing images from `/usr` to container storage `/var`. The MicroShift service will start only after this service shows "Active".
====

+
[source,sh,role=execute]
----
sudo systemctl status microshift
----

. Configure MicroShift (kubeconfig):
+
[source,sh,role=execute]
----
mkdir -p ~/.kube
sudo cat /var/lib/microshift/resources/kubeadmin/kubeconfig > ~/.kube/config
chmod go-r ~/.kube/config
----

=== Verification: Proving the "Air-Gap"
The critical proof of success is verifying that images were **not** pulled from the internet.

. Verify application readiness:
+
[source,sh,role=execute]
----
oc get nodes
oc get pods -A
----

. The "smoking gun" verification:
+
Check the Kubernetes events. You are looking for the message: **"Container image already present on machine"**.
+
[source,sh,role=execute]
----
oc get events -A | grep -i pull
----

[IMPORTANT]
====
If you see **"Successfully pulled"**, the system used the internet. If you see **"already present"**, you have successfully validated a disconnected, image-mode appliance!
====

[#validation]
== 3.4 Validation: Appliance Operating Successfully

=== Expected Results Checklist
[cols="1,2", options="header"]
|===
| Test | Expected Result
| **Boot Status** | `bootc status` shows active image.
| **Node State** | `Ready` state in `oc get nodes`.
| **App Status** | nginx pod is `Running`.
| **Offline Proof** | `crictl images` shows all images; Events show `already present`.
|===

=== Exploring Application Manifests (Optional)
To see how MicroShift manages the embedded workloads:
[source,sh,role=execute]
----
ls /etc/microshift/manifests.d/001-test-app/
----

[source,sh,role=execute]
----
oc get route

curl hello-route-default.apps.example.com
----

[NOTE]
====
Note the image reference `quay.io/nginx/nginx-unprivileged:latest`. Even though it looks like a remote URL, MicroShift is redirected to the **internal local storage** created during the image build.
====

---
**Next:** Proceed to xref:module-04.adoc[Module 4: Safe Updates & Rollbacks]
