= Module 4: Performing an Atomic Update 
:page-nav-title: Performing an Atomic Update

== Learning objectives
By the end of this module, you will be able to:

* Explain the A/B boot model and atomic update process
* Build an updated appliance image (v2)
* Perform an atomic system upgrade on a running appliance
* Verify system health using greenboot
* Understand rollback capabilities of RHEL Image Mode

[#atomic_updates]
== 4.1 The Power of Atomic Updates and Rollbacks
One of the biggest advantages of RHEL Image Mode is the **atomic update model**.  
Each appliance keeps two bootable system states:

* **A (current)** — the version currently running.
* **B (next)** — the version that will be activated after the next reboot.

When you apply an update, the system downloads a new image and stages it as the *next boot target*.  
If something goes wrong, RHEL Image Mode can roll back instantly to the previous working state — no reinstall, no manual recovery.

This approach provides:

* **Reliability:** Safe upgrades, always revertible.
* **Speed:** OS + apps update in one transaction.
* **Consistency:** Every node runs the same known-good image.
* **Confidence:** Upgrades don’t break your running workloads.

[NOTE]
====
This “A/B boot” concept ensures your field-deployed appliances can be updated safely — even with power loss or network issues mid-upgrade.
====

[#build_v2]
== 4.2 Hands-On: Build the Updated Image 
Now let’s create an updated version of our appliance: **v2**.  
In a real-world scenario, this could include:

* A new version of WordPress or another app,
* OS security updates, or
* Configuration changes.

The **`Containerfile.v2`** uses the **`v1` image as its base**, making this version faster to build and deploy.

. View the `Containerfile.v2` to see how it extends v1:
+
[source,sh,role=execute]
----
cat Containerfile.v2
----
+
Example content:
+
[%collapsible]
[source,dockerfile]
----
FROM localhost/microshift-4.19-bootc-embeeded:v1

## Needed as bootc-image-builder requires a repo file to be present in the base image.
# in the build.sh with TAG=v2, we replace the 4.19 repo with the 4.20 repo to allow upgrade MicroShift to 4.20. 
ADD redhat.repo /etc/yum.repos.d/redhat.repo
RUN dnf update --enablerepo=rhel-9-for-$(uname -m)-baseos-eus-rpms --enablerepo=rhel-9-for-x86_64-appstream-eus-rpms -y --releasever=9.6 && \
    dnf clean all

----

. Build the new `v2` image using the provided script:
+
[source,sh,role=execute]
----
time sudo bash -x build.sh v2 2>&1 | tee build-v2.log
----

Once the build completes, the resulting image and ISO will be available in the `/var/tmp/bootc-images/bootiso/` folder.

[NOTE]
====
Each new version is simply another container image — giving you Git-like versioning for your operating system.
====

[#upgrade]
== 4.3 Hands-On: Upgrade the Live System
Now that your updated image is ready, let’s **upgrade the running appliance** safely using atomic image switching.

. Stage the v2 image on your running appliance:
+
[source,sh,role=execute]
----
sudo bootc switch <registry_path>/<image_name>:v2
----
+
[NOTE]
====
If using a local registry instead of quay.io, replace the registry path accordingly. For example: `sudo bootc switch <local_registry_host>:<port>/microshift-4.19-bootc-embeeded:v2`
====

. Apply and reboot to activate the update:
+
[source,sh,role=execute]
----
sudo bootc upgrade --apply
sudo reboot
----

. After reboot, verify the system’s image version:
+
[source,sh,role=execute]
----
sudo bootc status
----

You should see the **v2 image** as the active deployment and **v1** available as a rollback target.

. Check system health using Greenboot (the service that validates system readiness after each boot):
+
[source,sh,role=execute]
----
systemctl status greenboot-healthcheck.service
----

. Review Greenboot logs to ensure update was successful:
+
[source,sh,role=execute]
----
journalctl -u greenboot-healthcheck.service
----
+
[NOTE]
====
You can also use `sudo greenboot status` to check the greenboot status. If Greenboot detects a failure (for example, MicroShift doesn't start correctly), it will automatically roll back to the previous working version.  
That's what makes RHEL Image Mode "atomic and safe by design". For more information on managing updates, see link:https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/9/html-single/using_image_mode_for_rhel_to_build_deploy_and_manage_operating_systems/index#managing-bootc-updates_using-image-mode-for-rhel[Managing bootc updates].
====

=== Validation checkpoint: Upgrade verification
After the system reboots, verify the upgrade was successful:

. Confirm v2 is now the active deployment:
+
[source,sh,role=execute]
----
sudo bootc status
----

. Verify greenboot health check passed:
+
[source,sh,role=execute]
----
sudo greenboot status
----

. Check that MicroShift is still running:
+
[source,sh,role=execute]
----
oc get nodes
oc get pods -A
----

. Verify rollback target is available:
+
[source,sh,role=execute]
----
sudo bootc status | grep -A 5 "rollback"
----

[IMPORTANT]
====
**Expected results:**

* `bootc status` should show v2 as the active deployment
* `greenboot status` should show "GREEN" indicating health checks passed
* MicroShift node should be in "Ready" state
* Application pods should still be running
* Previous v1 image should be available as a rollback target

If greenboot shows "RED" or MicroShift is not running, the system should automatically roll back. You can manually roll back using `sudo bootc rollback` if needed.
====

[#delta_updates]
== 4.4 Experimental: Delta Updates
In low-bandwidth environments, downloading an entire image for every update may not be practical.  
**Delta updates** solve this by transferring only the difference between versions (v1 → v2).

While this is still **experimental**, Red Hat and the container community are exploring it.  
You can experiment using the open-source link:https://github.com/containers/tar-diff[tar-diff] utility.

With tools like *tar-diff*, you can generate compact binary patches between image layers, reducing update sizes drastically — ideal for edge devices with limited connectivity.


[#summary]
== 4.5 Summary
You’ve just experienced the key differentiator of Image Mode:

* One-command upgrades with instant rollback.  
* Predictable, tested states across your entire fleet.  
* Optional support for smaller delta-based updates.  

Next: xref:module-05.adoc[Module 5: Troubleshooting & Advanced Topics]
