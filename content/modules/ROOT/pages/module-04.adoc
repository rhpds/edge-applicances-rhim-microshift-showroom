= Module 4: Performing an Atomic Update 
:page-nav-title: Performing an Atomic Update

[#atomic_updates]
== 4.1 The Power of Atomic Updates and Rollbacks
One of the biggest advantages of RHEL Image Mode is the **atomic update model**.  
Each appliance keeps two bootable system states:

* **A (current)** — the version currently running.
* **B (next)** — the version that will be activated after the next reboot.

When you apply an update, the system downloads a new image and stages it as the *next boot target*.  
If something goes wrong, RHEL Image Mode can roll back instantly to the previous working state — no reinstall, no manual recovery.

This approach provides:

* **Reliability:** Safe upgrades, always revertible.
* **Speed:** OS + apps update in one transaction.
* **Consistency:** Every node runs the same known-good image.
* **Confidence:** Upgrades don’t break your running workloads.

[NOTE]
====
This “A/B boot” concept ensures your field-deployed appliances can be updated safely — even with power loss or network issues mid-upgrade.
====

[#build_v2]
== 4.2 Hands-On: Build the Updated Image 
Now let’s create an updated version of our appliance: **v2**.  
In a real-world scenario, this could include:

* A new version of WordPress or another app,
* OS security updates, or
* Configuration changes.

The **`Containerfile.v2`** uses the **`v1` image as its base**, making this version faster to build and deploy.

. View the `Containerfile.v2` to see how it extends v1:
+
[source,sh,role=execute]
----
cat Containerfile.v2
----
+
Example content:
+
[%collapsible]
[source,dockerfile]
----
FROM localhost/microshift-4.19-bootc-embeeded:v1

## Needed as bootc-image-builder requires a repo file to be present in the base image.
# in the build.sh with TAG=v2, we replace the 4.19 repo with the 4.20 repo to allow upgrade MicroShift to 4.20. 
ADD redhat.repo /etc/yum.repos.d/redhat.repo
RUN dnf update --enablerepo=rhel-9-for-$(uname -m)-baseos-eus-rpms --enablerepo=rhel-9-for-x86_64-appstream-eus-rpms -y --releasever=9.6 && \
    dnf clean all

----

. Build the new `v2` image using the provided script:
+
[source,sh,role=execute]
----
time sudo bash -x build.sh v2 2>&1 | tee build-v2.log
----

Once the build completes, the resulting image and ISO will be available in the `/var/tmp/bootc-images/bootiso/` folder.

[NOTE]
====
Each new version is simply another container image — giving you Git-like versioning for your operating system.
====

[#upgrade]
== 4.3 Hands-On: Upgrade the Live System
Now that your updated image is ready, let’s **upgrade the running appliance** safely using atomic image switching.

. Stage the v2 image on your running appliance:
+
[source,sh,role=execute]
----
sudo bootc switch <registry_path>/<image_name>:v2
----
+
[NOTE]
====
If using a local registry instead of quay.io, replace the registry path accordingly. For example: `sudo bootc switch <local_registry_host>:<port>/microshift-4.19-bootc-embeeded:v2`
====

. Apply and reboot to activate the update:
+
[source,sh,role=execute]
----
sudo bootc upgrade --apply
sudo reboot
----

. After reboot, verify the system’s image version:
+
[source,sh,role=execute]
----
sudo bootc status
----

You should see the **v2 image** as the active deployment and **v1** available as a rollback target.

. Check system health using Greenboot (the service that validates system readiness after each boot):
+
[source,sh,role=execute]
----
systemctl status greenboot-healthcheck.service
----

. Review Greenboot logs to ensure update was successful:
+
[source,sh,role=execute]
----
journalctl -u greenboot-healthcheck.service
----
+
[NOTE]
====
You can also use `sudo greenboot status` to check the greenboot status. If Greenboot detects a failure (for example, MicroShift doesn't start correctly), it will automatically roll back to the previous working version.  
That's what makes RHEL Image Mode "atomic and safe by design".
====

[#delta_updates]
== 4.4 Experimental: Delta Updates
In low-bandwidth environments, downloading an entire image for every update may not be practical.  
**Delta updates** solve this by transferring only the difference between versions (v1 → v2).

While this is still **experimental**, Red Hat and the container community are exploring it.  
You can experiment using the open-source link:https://github.com/containers/tar-diff[tar-diff] utility.

With tools like *tar-diff*, you can generate compact binary patches between image layers, reducing update sizes drastically — ideal for edge devices with limited connectivity.


[#summary]
== 4.5 Summary
You’ve just experienced the key differentiator of Image Mode:
* One-command upgrades with instant rollback.  
* Predictable, tested states across your entire fleet.  
* Optional support for smaller delta-based updates.  

Next: xref:module-05.adoc[Module 5: Troubleshooting & Advanced Topics]
