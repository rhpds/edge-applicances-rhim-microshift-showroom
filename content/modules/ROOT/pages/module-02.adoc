= Module 2: Building the Self-Contained Appliance 
:page-nav-title: Build the Self-Contained Appliance
:icons: font
:source-highlighter: rouge
:experimental:

[#containerfile]
== 2.1 Anatomy of a bootc Appliance Containerfile
A `Containerfile` is the recipe for your appliance. It defines:

* The base OS (RHEL)
* MicroShift components
* Tools the appliance needs

Let’s take a quick look at the file used to build our base image, which is inspired by downstream MicroShift link:https://docs.redhat.com/en/documentation/red_hat_build_of_microshift/4.19/html/installing_with_image_mode_for_rhel/installing-a-bootc-image-and-publishing-to-a-registry#microshift-install-bootc-build-image_microshift-install-bootc-image[documentation].

. View the `Containerfile` for the base image:
+
[source,sh,role=execute]
----
cat Containerfile.base
----
+
[%collapsible]
====
.Output of `$cat Containerfile.base`
[source,dockerfile]
----
FROM registry.redhat.io/rhel9-eus/rhel-9.6-bootc:9.6
ARG VERSION_ID="9.6"

## Needed as bootc-image-builder requires a repo file to be present in the base image.
ADD redhat.repo /etc/yum.repos.d/redhat.repo
# workaround for this lab, as we didn't managed to push signatures for lvm operator and ubi images from registry.redhat.io 
ADD policy.json /etc/containers/policy.json

RUN dnf install -y --releasever="${VERSION_ID}" firewalld jq microshift microshift-release-info cockpit openscap-utils scap-security-guide && \
    systemctl enable microshift && \
    dnf clean all

# Create a default 'redhat' user with the specified password.
# Add it to the 'wheel' group to allow for running sudo commands.
ARG USER_PASSWD
RUN if [ -z "${USER_PASSWD}" ] ; then \
        echo USER_PASSWD is a mandatory build argument && exit 1 ; \
    fi

RUN useradd -m -d /var/home/redhat -G wheel redhat && \
    echo "redhat:${USER_PASSWD}" | chpasswd

# Mandatory firewall configuration
RUN firewall-offline-cmd --zone=public --add-port=22/tcp && \
    firewall-offline-cmd --zone=trusted --add-source=10.42.0.0/16 && \
    firewall-offline-cmd --zone=trusted --add-source=169.254.169.1 && \
    firewall-offline-cmd --zone=trusted --add-source=fd01::/48
    # Application-specific firewall configuration
RUN firewall-offline-cmd --zone=public --add-port=80/tcp && \
    firewall-offline-cmd --zone=public --add-port=443/tcp && \
    firewall-offline-cmd --zone=public --add-port=30000-32767/tcp && \
    firewall-offline-cmd --zone=public --add-port=30000-32767/udp

# Create a systemd unit to recursively make the root filesystem subtree
# shared as required by OVN images
RUN cat > /etc/systemd/system/microshift-make-rshared.service <<'EOF'
[Unit]
Description=Make root filesystem shared
Before=microshift.service
ConditionVirtualization=container
[Service]
Type=oneshot
ExecStart=/usr/bin/mount --make-rshared /
[Install]
WantedBy=multi-user.target
EOF

RUN systemctl enable microshift-make-rshared.service

COPY wordpress /usr/lib/microshift/manifests.d/wordpress

## Apply kernel tuning for CIS hardening compliance
RUN cat > /etc/sysctl.d/99-cis-hardening.conf <<'EOF'
# IPv6 Settings
net.ipv6.conf.all.accept_ra = 0
net.ipv6.conf.all.accept_redirects = 0
net.ipv6.conf.default.accept_ra = 0
net.ipv6.conf.default.accept_redirects = 0
# IPv4 Settings
net.ipv4.conf.all.log_martians = 1
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.log_martians = 1
net.ipv4.conf.default.secure_redirects = 0
net.ipv4.ip_forward = 0
# Ptrace Scope
kernel.yama.ptrace_scope = 1
EOF
RUN echo "AllowUsers redhat" >> /etc/ssh/sshd_config
# Run scan and hardening
RUN oscap-im --profile xccdf_org.ssgproject.content_profile_cis /usr/share/xml/scap/ssg/content/ssg-rhel9-ds.xml
----
====

This shows how the base RHEL image is extended with MicroShift and supporting packages.

[NOTE]
====
You don’t need to modify this file during the lab — this is just to understand what’s inside the appliance.
====

[#physically_bound]
== 2.2 Creating “Physically-Bound” Images
A physically-bound image contains everything the appliance needs to run — **including the application container images**.

This allows the system to:

* Boot and run apps with **no internet connection**
* Start MicroShift with pre-embedded containers
* Run workloads immediately after boot

Now let’s inspect the `v1` Containerfile that embeds the application containers.

. View the `Containerfile` for the v1 appliance:
+
[source,sh,role=execute]
----
cat Containerfile.v1
----
+
[%collapsible]
====
.Output of $cat Containerfile.v1
[source,dockerfile]

----
FROM localhost/microshift-4.19-bootc:latest

ARG USHIFT_BASE_IMAGE_NAME
ARG USHIFT_BASE_IMAGE_TAG

ENV IMAGE_STORAGE_DIR=/usr/lib/containers/storage
ENV IMAGE_LIST_FILE=${IMAGE_STORAGE_DIR}/image-list.txt

# use to embed application images
COPY ./embed_image.sh /usr/bin/
COPY ./copy_embedded_images.sh /usr/bin/

ENV IMAGE_STORAGE_DIR=/usr/lib/containers/storage
ENV IMAGE_LIST_FILE=${IMAGE_STORAGE_DIR}/image-list.txt

# Pull the container images into /usr/lib/containers/storage:
# - Each image goes into a separate sub-directory
# - Sub-directories are named after the image reference string SHA
# - An image list file maps image references to their name SHA
# First for MicroShift payload
RUN --mount=type=secret,id=pullsecret,dst=/run/secrets/pull-secret.json \
    images="$(jq -r ".images[]" /usr/share/microshift/release/release-"$(uname -m)".json)" ; \
    mkdir -p "${IMAGE_STORAGE_DIR}" ; \
    for img in ${images} ; do \
       /usr/bin/embed_image.sh ${img} --authfile /run/secrets/pull-secret.json ; \
     done 
# Then for Applications
RUN --mount=type=secret,id=pullsecret,dst=/run/secrets/pull-secret.json <<PULL
    /usr/bin/embed_image.sh docker.io/library/wordpress:6.2.1-apache
    /usr/bin/embed_image.sh docker.io/library/mysql:8.0
PULL

# 

RUN mkdir -p /etc/systemd/system/microshift.service.d
RUN cat > /etc/systemd/system/microshift.service.d/microshift-copy-images.conf <<EOF
[Service]
ExecStartPre=/bin/bash /usr/bin/copy_embedded_images.sh
EOF
----
====

This file builds on the base image and adds the embedded container images that will be used during MicroShift startup.

[NOTE]
====
You’ll also notice helper scripts in the repository that copy container images into the image during build time.  
These ensure the system can run fully offline.
====

[#build]
== 2.3 Hands-On: Build the Base and v1 Images
Now you’ll run the build scripts that assemble the appliance.

Before running them, you may want to quickly look at the scripts to understand what they do.

. (Optional) View the build script for the base image:
+
[source,sh,role=execute]
----
cat build-base.sh
----
+
[%collapsible]
====
.Build script: `build-base.sh` (output of `cat build-base.sh`)
[source,bash]
----
#!/bin/bash
USER_PASSWD=redhat02
IMAGE_NAME=microshift-4.19-bootc

dnf config-manager \
        --set-enabled rhocp-4.19-for-rhel-9-$(uname -m)-rpms \
        --set-enabled fast-datapath-for-rhel-9-$(uname -m)-rpms
dnf config-manager --set-disabled rhocp-4.18-for-rhel-9-$(uname -m)-rpms --set-disabled rhocp-4.20-for-rhel-9-$(uname -m)-rpms
cp /etc/yum.repos.d/redhat.repo /home/lab-user/bootc-embeeded-containers
cp /etc/containers/policy.json /home/lab-user/bootc-embeeded-containers
# Run podman build as root to allow for :z relabeling
#
# Mount the host subscription data
#
# In this lab there is no need for --authfile / pullsecret as we are pulling from a disconnected unsecure registry
sudo podman build -t ${IMAGE_NAME} \
    --build-arg USER_PASSWD=${USER_PASSWD} \
    --volume /etc/rhsm:/etc/rhsm:ro,z \
    --volume /etc/pki/entitlement:/etc/pki/entitlement:ro,z \
    --volume /etc/yum.repos.d:/etc/yum.repos.d:ro,z \
    -f Containerfile.base

----
====

. Build the base image (~5 minutes):
+
[source,sh,role=execute]
----
time sudo bash -x build-base.sh 2>&1 | tee build-base.log
----

. (Optional) View the build script for `v1`:
+
[source,sh,role=execute]
----
cat build.sh
----
+
[%collapsible]
====
.Build script: `build.sh` (output of `cat build.sh`)
[source,bash]
----
#!/bin/bash
set -e

REGISTRY_URL=quay.io
TAG=$1

if [ -z "$TAG" ]; then
    echo "Error: a tag must be provided."
    echo "Usage: $0 <tag>"
    exit 1
fi

# Set IMAGE_NAME and BASE_IMAGE_NAME based on TAG (case-insensitive)
TAG_LOWER=$(echo "$TAG" | tr '[:upper:]' '[:lower:]')
case "$TAG_LOWER" in
    v1)
        IMAGE_NAME=microshift-4.19-bootc-embeeded
        BASE_IMAGE_NAME=microshift-4.19-bootc:${TAG}
        ;;
    v2)
        IMAGE_NAME=microshift-4.20-bootc-embeeded
        BASE_IMAGE_NAME=microshift-4.20-bootc:${TAG}
        ;;
    *)
        echo "Error: TAG must be either v1/V1 or v2/V2"
        exit 1
        ;;
esac

#REGISTRY_IMG="rhn_support_arolivei/${IMAGE_NAME}"

# For v2, configure dnf repositories
if [ "$TAG_LOWER" = "v2" ]; then
    echo "#### Configuring dnf repositories for v2"
    sudo dnf config-manager \
        --set-enabled rhocp-4.20-for-rhel-9-$(uname -m)-rpms \
        --set-enabled fast-datapath-for-rhel-9-$(uname -m)-rpms
    sudo dnf config-manager \
        --set-disabled rhocp-4.18-for-rhel-9-$(uname -m)-rpms \
        --set-disabled rhocp-4.19-for-rhel-9-$(uname -m)-rpms
    cp /etc/yum.repos.d/redhat.repo /home/lab-user/bootc-embeeded-containers
fi

echo "#### Building a new bootc image with MicroShift and application Container images embeeded to it"
sudo podman build -t "${IMAGE_NAME}:${TAG}" \
    --volume /etc/rhsm:/etc/rhsm:ro,z \
    --volume /etc/pki/entitlement:/etc/pki/entitlement:ro,z \
    --volume /etc/yum.repos.d:/etc/yum.repos.d:ro,z \
    --volume /etc/containers/registries.conf.d/99-mirrors.conf:/etc/containers/registries.conf.d/99-mirrors.conf:ro,z \
    --volume /etc/containers/policy.json:/etc/containers/policy.json:ro,z \
    --build-arg USHIFT_BASE_IMAGE_NAME="${BASE_IMAGE_NAME}" \
    --build-arg USHIFT_BASE_IMAGE_TAG=${TAG} \
    -f Containerfile.${TAG}

#echo "#### pushing bootc image to a registry"
#podman push "localhost/${IMAGE_NAME}:${TAG}" "${REGISTRY_URL}/${REGISTRY_IMG}:${TAG}"

sudo mkdir -p /var/tmp/bootc-images
echo "#### creating ISO from bootc image"
sudo podman run --rm -it --privileged --security-opt label=type:unconfined_t \
   -v /var/lib/containers/storage:/var/lib/containers/storage \
   -v /var/tmp/bootc-images:/output \
   --volume /etc/rhsm:/etc/rhsm:ro \
   --volume /etc/pki/entitlement:/etc/pki/entitlement:ro \
    registry.redhat.io/rhel9/bootc-image-builder:latest \
    --progress=verbose --local --type iso localhost/${IMAGE_NAME}:${TAG}
----
====

. Build the v1 appliance image (this produces the bootable ISO in around 10 to 15 minutes):
+
[source,sh,role=execute]
----
time sudo bash -x build.sh v1 2>&1 | tee build-v1.log
----

When the build completes, the ISO will appear in the `_build/` directory.

[NOTE]
====
This ISO contains the OS, MicroShift, and all embedded container images — ready to run in an offline or air-gapped environment.
====

== 2.4 What happens next
Once installed on the target VM:
* The embedded container images are already available locally.
* Before MicroShift starts, these images are added to the running system.
* MicroShift then starts and launches your applications without needing any external registry.

This pattern ensures predictable, repeatable, and offline-friendly deployments.

Next: xref:module-03.adoc[Module 3: Booting and Verifying the Appliance]
