= Module 2: Building Self-Contained Appliances
:page-nav-title: Build the Self-Contained Appliance
:icons: font
:source-highlighter: rouge
:experimental:

== Learning objectives
By the end of this module, you will be able to:

* Understand the structure of a bootc Containerfile and how it extends a base RHEL image
* Explain why EUS (Extended Update Support) images are used for appliances
* Explain why `redhat.repo` (or equivalent) is embedded in the base image
* Explain physically-bound images and how container images are embedded immutably
* Understand why embedded images are placed under `/usr/lib` rather than `/var`
* Build a base RHEL image with MicroShift using Podman
* Build a self-contained appliance image with embedded applications
* Generate a bootable ISO from a container image using the bootc-image-builder

[#know_section]
[#containerfile]
== 2.1 Know: Building Self-Contained Appliances

=== The Business Challenge

Remember ManufacturingCo from the introduction? They need to deploy appliances to 50 factory locations, many of which have intermittent or no network connectivity. Traditional approaches require:

* Pulling container images from registries at runtime
* Network access for application deployments
* Manual configuration and package management
* Complex multi-step deployment processes

**The Problem:** How do we create appliances that work completely offline, eliminating the need for runtime registry access and network dependencies?

=== Why We Need Self-Contained Appliances

Self-contained appliances solve the **disconnected operations challenge** we discussed in Module 1. By embedding everything needed to run—the OS, MicroShift, and application container images—directly into the bootable image, we enable:

* **True offline operation:** Appliances boot and run applications without any internet access
* **Deterministic deployments:** Every appliance matches exactly what you validated in testing
* **Simplified deployment:** Single ISO file contains everything needed
* **Consistent behavior:** No variation due to network conditions or registry availability

=== How Containerfiles Solve This Problem

A `Containerfile` is the recipe for your appliance. It defines:

* The base OS (RHEL bootc base)
* MicroShift components and required RPMs
* System configuration, firewall, and hardening
* Embedded manifests (Quadlets) and application images
* Scripts or units to import embedded images at runtime

This single file approach transforms appliance creation from a complex, multi-step process into a **version-controlled, repeatable build** that solves the disconnected deployment challenge.

=== Why Use EUS (Extended Update Support)?

We choose **EUS** images for appliances because they provide:

* Long lifecycle stability (fewer, predictable changes)
* A predictable minor release stream (helpful for validated appliances)
* A better platform match for long-running edge/industrial deployments

Appliances typically prefer stability and predictability over the fastest-moving release. This aligns with customer needs for reliable, long-running edge deployments.

=== Why Embed `redhat.repo` (or repo metadata) into the image?

`bootc-image-builder` and container-based builds use `dnf` within the image build. To ensure `dnf` can resolve packages during build, the base image must contain repo metadata (for example `/etc/yum.repos.d/redhat.repo`). Embedding the repo file inside the base ensures that:

* Builds are reproducible (the same repos used each time).
* `dnf` can perform package installs during the container build step.
* The image builder has the correct subscription/repo context.

. View the `Containerfile` for the base image:
+
[source,sh,role=execute]
----
cat Containerfile.base
----
+
[%collapsible]
====
.Output of `$cat Containerfile.base`
[source,dockerfile]
----
FROM registry.redhat.io/rhel9-eus/rhel-9.6-bootc:9.6
ARG VERSION_ID="9.6"

## Needed as bootc-image-builder requires a repo file to be present in the base image.
ADD redhat.repo /etc/yum.repos.d/redhat.repo
# workaround for this lab, as we didn't managed to push signatures for lvm operator and ubi images from registry.redhat.io 
ADD policy.json /etc/containers/policy.json

RUN dnf install -y --releasever="${VERSION_ID}" firewalld jq microshift microshift-release-info cockpit openscap-utils scap-security-guide && \
    systemctl enable microshift && \
    dnf clean all

# Create a default 'redhat' user with the specified password.
# Add it to the 'wheel' group to allow for running sudo commands.
ARG USER_PASSWD
RUN if [ -z "${USER_PASSWD}" ] ; then \
        echo USER_PASSWD is a mandatory build argument && exit 1 ; \
    fi

RUN useradd -m -d /var/home/redhat -G wheel redhat && \
    echo "redhat:${USER_PASSWD}" | chpasswd

# Mandatory firewall configuration
RUN firewall-offline-cmd --zone=public --add-port=22/tcp && \
    firewall-offline-cmd --zone=trusted --add-source=10.42.0.0/16 && \
    firewall-offline-cmd --zone=trusted --add-source=169.254.169.1 && \
    firewall-offline-cmd --zone=trusted --add-source=fd01::/48
    # Application-specific firewall configuration
RUN firewall-offline-cmd --zone=public --add-port=80/tcp && \
    firewall-offline-cmd --zone=public --add-port=443/tcp && \
    firewall-offline-cmd --zone=public --add-port=30000-32767/tcp && \
    firewall-offline-cmd --zone=public --add-port=30000-32767/udp

# Create a systemd unit to recursively make the root filesystem subtree
# shared as required by OVN images
RUN cat > /etc/systemd/system/microshift-make-rshared.service <<'EOF'
[Unit]
Description=Make root filesystem shared
Before=microshift.service
ConditionVirtualization=container
[Service]
Type=oneshot
ExecStart=/usr/bin/mount --make-rshared /
[Install]
WantedBy=multi-user.target
EOF

RUN systemctl enable microshift-make-rshared.service

COPY wordpress /usr/lib/microshift/manifests.d/wordpress
----
====

This Containerfile extends the RHEL EUS bootc base image, installs MicroShift, configures firewall rules, and places manifests for MicroShift.

[NOTE]
====
You don't need to edit `Containerfile.base` for this lab — we show it so you understand what's being installed into the appliance.
====

[NOTE]
====
**Layered vs. Fresh Images:** This workshop demonstrates building layered images (RHEL base → MicroShift base → embedded 4.19 → embedded 4.20) for faster incremental builds. However, `bootc switch` does not require layered images—you can build and switch to completely fresh, independent images built directly from the RHEL base. Building fresh images for each version can help manage image sizes, as each image contains only the necessary components without accumulating redundant data from previous layers. For more information, see link:https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/9/html-single/using_image_mode_for_rhel_to_build_deploy_and_manage_operating_systems/index#managing-bootc-updates_using-image-mode-for-rhel[Managing bootc updates].
====

[#physically_bound]
== 2.2 Know: Physically-Bound Images for Disconnected Operations

=== Remember the Disconnected Operations Challenge?

In the introduction, we discussed how many edge devices have intermittent or no network connectivity, making traditional update and management approaches impractical. ManufacturingCo's factory locations often operate in disconnected or bandwidth-constrained networks.

**The Challenge:** How do we ensure appliances can run cloud-native applications (like WordPress and MySQL) without requiring runtime registry access?

=== Physically-Bound Images: The Solution

A **physically-bound** image contains everything needed to run: the OS, MicroShift, application container images, and any Quadlets/manifests. This enables **true offline operation**.

**Business Value:**
* Boot and run applications without any internet access
* MicroShift can start and immediately use local images
* Deterministic appliances that match exactly what you validated
* No runtime registry dependency—eliminates network connectivity requirements

This solves the disconnected operations challenge by making the appliance completely self-contained.

=== The Immutability Reason: `/usr` vs `/var`

Under Image Mode the root filesystem is treated as read-only at runtime. Key points:

* `/usr` — written during the build process, becomes part of the image and is versioned with the OS.
* `/var` — runtime data store; mutable and not intended to be the place for versioned, build-time assets.

Storing embedded images under `/usr/lib/...` makes them part of the immutable image and ensures:

* Images are versioned together with the OS image
* They are upgrade-safe and roll back with the OS
* They cannot be accidentally mutated at runtime

If we stored them in `/var`, they would not be tied to the OS image lifecycle and could drift—defeating the purpose of immutable, versioned appliances.

=== How Physical Embedding Works

We embed images using `skopeo` and the `dir:` transport during the **build**.

*Embed into a directory inside the image (build time):*

[source,bash]
----
RUN skopeo copy --preserve-digests docker://registry.example.com/my-app:1.0 \
    dir:/usr/lib/containers-image-cache/my-app-1.0
----

This creates a directory that contains the image content and preserves digests so references by SHA still work.

*At runtime (first boot or ExecStartPre), import into Podman's mutable store:*

[source,bash]
----
/usr/bin/skopeo copy --preserve-digests \
    dir:/usr/lib/containers-image-cache/my-app-1.0 \
    containers-storage:registry.example.com/my-app@sha256:<digest>
----

This loads the embedded data into the Podman storage so MicroShift (or kubelet/container runtimes) can reference the image by name or digest.

=== Why `dir:` Transport?

* `dir:` allows bundling multiple images under one directory.
* It preserves image digests (crucial for referencing by SHA).
* It's file-system friendly and portable within the ISO.

=== Why Not Use a Secondary Image Store?

A secondary store is not replaced during an OS upgrade. Embedded images *change with each OS image* and must live inside that OS image to be versioned and rolled back together. That's why we place them under `/usr/lib`.

=== Helper Scripts

This repo includes two helper scripts you'll see and can inspect:

* `embed_image.sh` — used during the Containerfile build to `skopeo copy` an image into the `/usr/lib/...` dir.  
  - Usage: `embed_image.sh <image-reference> [--all] [--authfile ...]`  
  - If referencing a manifest list by digest, use `--all` so `skopeo` copies the whole manifest list and ALL variant images.

* `copy_embedded_images.sh` — invoked at boot (via a systemd ExecStartPre) to copy all embedded `dir:` images into the Podman container store (containers-storage), making them available to MicroShift.

Upstream example / reference for patterns:
link:https://gitlab.com/fedora/bootc/examples/-/tree/main/physically-bound-images[physically-bound-images examples].

. View the `Containerfile` for the 4.19 appliance (embedding step):
+
[source,sh,role=execute]
----
cat Containerfile.4.19
----
+
[%collapsible]
====
.Output of `$cat Containerfile.4.19`
[source,dockerfile]
----
FROM localhost/microshift-bootc:base

ARG USHIFT_BASE_IMAGE_NAME
ARG USHIFT_BASE_IMAGE_TAG

ENV IMAGE_STORAGE_DIR=/usr/lib/containers/storage
ENV IMAGE_LIST_FILE=${IMAGE_STORAGE_DIR}/image-list.txt

# use to embed application images
COPY ./embed_image.sh /usr/bin/
COPY ./copy_embedded_images.sh /usr/bin/

ENV IMAGE_STORAGE_DIR=/usr/lib/containers/storage
ENV IMAGE_LIST_FILE=${IMAGE_STORAGE_DIR}/image-list.txt

# Pull the container images into /usr/lib/containers/storage:
# - Each image goes into a separate sub-directory
# - Sub-directories are named after the image reference string SHA
# - An image list file maps image references to their name SHA
# First for MicroShift payload
RUN --mount=type=secret,id=pullsecret,dst=/run/secrets/pull-secret.json \
    images="$(jq -r ".images[]" /usr/share/microshift/release/release-"$(uname -m)".json)" ; \
    mkdir -p "${IMAGE_STORAGE_DIR}" ; \
    for img in ${images} ; do \
       /usr/bin/embed_image.sh ${img} --authfile /run/secrets/pull-secret.json ; \
     done 
# Then for Applications
RUN --mount=type=secret,id=pullsecret,dst=/run/secrets/pull-secret.json <<PULL
    /usr/bin/embed_image.sh docker.io/library/wordpress:6.2.1-apache
    /usr/bin/embed_image.sh docker.io/library/mysql:8.0
PULL

# 

RUN mkdir -p /etc/systemd/system/microshift.service.d
RUN cat > /etc/systemd/system/microshift.service.d/microshift-copy-images.conf <<EOF
[Service]
ExecStartPre=/bin/bash /usr/bin/copy_embedded_images.sh
EOF
----
====

[#show_section]
[#build_base]
== 2.3 Show: Build the Base Image

=== Why We're Doing This

We're building the foundation that solves the **configuration drift challenge**. The base image provides a consistent, known-good starting point that includes MicroShift and system configuration. This ensures every appliance built from this base will have identical components, eliminating the "it works on my machine" problem.

=== Build the Base Image

Now you'll run the build script that creates the base image. We suggest you **inspect** (cat) the script first, then run the build so you understand what it does.

. (Optional) View the build script for the base image:
+
[source,sh,role=execute]
----
cat build-base.sh
----
+
[%collapsible]
====
.Build script: `build-base.sh` (abridged)
[source,bash]
----
#!/bin/bash
USER_PASSWD=redhat02
IMAGE_NAME=microshift-bootc:base

dnf config-manager \
        --set-enabled rhocp-4.19-for-rhel-9-$(uname -m)-rpms \
        --set-enabled fast-datapath-for-rhel-9-$(uname -m)-rpms
dnf config-manager --set-disabled rhocp-4.18-for-rhel-9-$(uname -m)-rpms --set-disabled rhocp-4.20-for-rhel-9-$(uname -m)-rpms
cp /etc/yum.repos.d/redhat.repo /home/lab-user/bootc-embeeded-containers
cp /etc/containers/policy.json /home/lab-user/bootc-embeeded-containers
# Run podman build as root to allow for :z relabeling
#
# Mount the host subscription data
#
# In this lab there is no need for --authfile / pullsecret as we are pulling from a disconnected unsecure registry
sudo podman build -t ${IMAGE_NAME} \
    --build-arg USER_PASSWD=${USER_PASSWD} \
    --volume /etc/rhsm:/etc/rhsm:ro,z \
    --volume /etc/pki/entitlement:/etc/pki/entitlement:ro,z \
    --volume /etc/yum.repos.d:/etc/yum.repos.d:ro,z \
    -f Containerfile.base
----
====

. Build the base image (~5 minutes):
+
[source,sh,role=execute]
----
time sudo bash -x build-base.sh 2>&1 | tee build-base.log
----

=== How This Solves the Problem

By building a consistent base image, we're creating the foundation for solving configuration drift. Every appliance built from this base will have:

* Identical MicroShift components
* Consistent system configuration
* Same firewall rules and security settings
* Predictable behavior across all deployments

This base image becomes the starting point for all appliance variants, ensuring consistency across ManufacturingCo's 50 factory locations.

[#build_appliance]
== 2.4 Show: Build the Self-Contained Appliance (4.19)

=== Why We're Doing This

This embeds applications directly into the OS image, solving the **disconnected operations challenge**. By embedding WordPress, MySQL, and MicroShift payload images, we create a truly self-contained appliance that can run completely offline—no runtime registry pulls required.

=== Build the 4.19 Appliance Image

Now you'll build the self-contained appliance that embeds all container images. This is where we solve the disconnected operations challenge.

. (Optional) View the build script:
+
[source,sh,role=execute]
----
cat build.sh
----
+
[%collapsible]
====
.Build script: `build.sh` (abridged)
[source,bash]
----
#!/bin/bash
set -e

REGISTRY_URL=quay.io
TAG=$1

if [ -z "$TAG" ]; then
    echo "Error: a tag must be provided."
    echo "Usage: $0 <tag>"
    exit 1
fi

# Set IMAGE_NAME and BASE_IMAGE_NAME based on TAG (case-insensitive)
TAG_LOWER=$(echo "$TAG" | tr '[:upper:]' '[:lower:]')
case "$TAG_LOWER" in
    4.19)
        IMAGE_NAME=microshift-bootc-embeeded
        BASE_IMAGE_NAME=microshift-bootc:base
        ;;
    4.20)
        IMAGE_NAME=microshift-bootc-embeeded
        BASE_IMAGE_NAME=microshift-bootc:4.19
        ;;
    *)
        echo "Error: TAG must be either 4.19 or 4.20"
        exit 1
        ;;
esac

#REGISTRY_IMG="rhn_support_arolivei/${IMAGE_NAME}"

# For 4.20, configure dnf repositories
if [ "$TAG_LOWER" = "4.20" ]; then
    echo "#### Configuring dnf repositories for 4.20"
    sudo dnf config-manager \
        --set-enabled rhocp-4.20-for-rhel-9-$(uname -m)-rpms \
        --set-enabled fast-datapath-for-rhel-9-$(uname -m)-rpms
    sudo dnf config-manager \
        --set-disabled rhocp-4.18-for-rhel-9-$(uname -m)-rpms \
        --set-disabled rhocp-4.19-for-rhel-9-$(uname -m)-rpms
    cp /etc/yum.repos.d/redhat.repo /home/lab-user/bootc-embeeded-containers
fi

echo "#### Building a new bootc image with MicroShift and application Container images embeeded to it"
sudo podman build -t "${IMAGE_NAME}:${TAG}" \
    --volume /etc/rhsm:/etc/rhsm:ro,z \
    --volume /etc/pki/entitlement:/etc/pki/entitlement:ro,z \
    --volume /etc/yum.repos.d:/etc/yum.repos.d:ro,z \
    --volume /etc/containers/registries.conf.d/99-mirrors.conf:/etc/containers/registries.conf.d/99-mirrors.conf:ro,z \
    --volume /etc/containers/policy.json:/etc/containers/policy.json:ro,z \
    --build-arg USHIFT_BASE_IMAGE_NAME="${BASE_IMAGE_NAME}" \
    --build-arg USHIFT_BASE_IMAGE_TAG=${TAG} \
    -f Containerfile.${TAG}

#echo "#### pushing bootc image to a registry"
#podman push "localhost/${IMAGE_NAME}:${TAG}" "${REGISTRY_URL}/${REGISTRY_IMG}:${TAG}"

# Only create ISO for 4.19
if [ "$TAG_LOWER" = "4.19" ]; then
    sudo mkdir -p /var/tmp/bootc-images
    echo "#### creating ISO from bootc image"
    sudo podman run --rm -it --privileged --security-opt label=type:unconfined_t \
       -v /var/lib/containers/storage:/var/lib/containers/storage \
       -v /var/tmp/bootc-images:/output \
       --volume /etc/rhsm:/etc/rhsm:ro \
       --volume /etc/pki/entitlement:/etc/pki/entitlement:ro \
        registry.redhat.io/rhel9/bootc-image-builder:latest \
        --progress=verbose --local --type iso localhost/${IMAGE_NAME}:${TAG}

    cp -v /var/tmp/bootc-images/bootiso/install.iso microshift-bootc-embeeded-4.19.iso
fi
----
====

. Build the 4.19 appliance image (~10–15 minutes):
+
[source,sh,role=execute]
----
time sudo bash -x build.sh 4.19 2>&1 | tee build-4.19.log
----

When the build completes, the ISO will appear in `/var/tmp/bootc-images/bootiso/` or `_build/`.

=== How This Solves the Problem

By embedding all container images into the OS image, we've created a truly self-contained appliance that:

* **Operates completely offline:** No network access required after deployment
* **Eliminates runtime registry dependency:** All images are already present in the ISO
* **Ensures deterministic behavior:** Every appliance matches exactly what was validated
* **Simplifies deployment:** Single ISO file contains everything needed

This solves the disconnected operations challenge for ManufacturingCo's factory locations, enabling deployment to any location regardless of network connectivity.

[#validation]
== 2.5 Validation: Appliance Ready for Deployment

=== Verify Build Success

Before proceeding, verify that both images were built successfully and the ISO is ready for deployment:

. Check that the base image exists:
+
[source,sh,role=execute]
----
sudo podman images | grep microshift-bootc:base
----

. Verify the 4.19 appliance image exists:
+
[source,sh,role=execute]
----
sudo podman images | grep microshift-bootc-embeeded:4.19
----

. Confirm the ISO file was created:
+
[source,sh,role=execute]
----
ls -lh /var/tmp/bootc-images/bootiso/*.iso || ls -lh _build/*.iso
----

=== Expected Results

[IMPORTANT]
====
**Expected results:**

* Base image `localhost/microshift-bootc:base` should be present
* Appliance image `localhost/microshift-bootc-embeeded:4.19` should be present
* ISO file `microshift-bootc-embeeded-4.19.iso` should exist in `/var/tmp/bootc-images/bootiso/` or `_build/`
* ISO file size will likely be several GB (it contains embedded container images)
====

=== Validation Checklist

□ Base image `microshift-bootc:base` exists  
□ Appliance image `microshift-bootc-embeeded:4.19` exists  
□ ISO file exists and is several GB in size  
□ Build logs show no errors

=== What Happens Next

Once installed on the target VM:

* Embedded images are available *before* MicroShift starts
* The systemd ExecStartPre runs `copy_embedded_images.sh` to populate the container store
* MicroShift launches workloads immediately — no external registry needed

This pattern ensures predictable, repeatable, and offline-friendly deployments—solving the disconnected operations challenge.

---

**Next:** Proceed to xref:module-03.adoc[Module 3: Deploying to Edge Locations] to deploy this self-contained appliance and verify it operates without network access.
