= Module 2: Building self-contained appliances
:page-nav-title: Build the Self-Contained Appliance
:icons: font
:source-highlighter: rouge
:experimental:

== Learning objectives
By the end of this module, you will be able to:

* [x] Read and explain a bootc Containerfile
* [x] Understand why a stable stream baseline matters for long-lived appliances
* [x] Explain why repo metadata (`centos.repo`) must be embedded
* [x] Define physically-bound images and why they matter for edge
* [x] Explain why embedded images live under `/usr` instead of `/var`
* [x] Build a MicroShift-enabled base image
* [x] Build a self-contained appliance with embedded workloads
* [x] Generate a bootable ISO using `bootc-image-builder`

[#know_section]
[#containerfile]
== 2.1 Know: Building Self-Contained Appliances

=== The Business Challenge
ManufacturingCo needs to deploy the same appliance to 50 factory sites — including locations with **intermittent or no network**.

[cols="1,2a", options="header"]
|===
| Traditional Method Pain Points | bootc Solution
| Pulling application images at runtime | **Physically-bound images:** Apps are inside the OS.
| Constant registry access required | **True offline operation:** No registry dependency.
| Manual package installs and config steps | **Deterministic deployments:** Every image is identical.
| Multi-stage deployment complexity | **Single artifact delivery:** One ISO deploys the full system.
|===

=== How Containerfiles Solve This Problem
The `Containerfile` is the **single file** that defines the whole appliance. It replaces many manual steps with a predictable build process.

[cols="1a,1a", options="header"]
|===
| ❌ Legacy Workflow | ✅ Containerfile Workflow
| **Build → Install → Configure** | **Define → Build → Ship → Deploy**
| Multi-step, manual, and prone to "drift" between sites. | Entire stack is unified in one version-controlled file.
|===



**What the Containerfile Defines:**

* **Base OS:** The specific CentOS Stream bootc base image.
* **MicroShift:** The core orchestration and required packages.
* **System Config:** Hardened firewall and security settings.
* **Workloads:** Quadlets, manifests, and the logic to embed application images.

=== Why We Use a Stable Stream Baseline
We choose a stable stream baseline because edge deployments value stability over rapid changes:

* **Lifecycle Sync:** Align compatibility with the upstream MicroShift matrix.
* **Predictable Updates:** Stick to a tested CentOS Stream snapshot for long-lived appliances.
* **Security without Friction:** Critical patches without minor version jumps.

=== View the Base Containerfile

. View the Base CentOS 9 Containerfile:
+
[source,sh,role=execute]
----
cat Containerfile
----
+
[%collapsible]
====
.Output of `$cat Containerfile`
[source,dockerfile]
----
FROM quay.io/centos-bootc/centos-bootc:stream9

# --------------------------------------------------
# Global speed optimizations
# --------------------------------------------------
RUN echo "install_weak_deps=False" >> /etc/dnf/dnf.conf

ARG ARCH=x86_64
ENV MICROSHIFT_RPM_URL=https://github.com/microshift-io/microshift/releases/download/4.21.0_gbc8e20c07_4.21.0_okd_scos.ec.14/microshift-rpms-${ARCH}.tgz

# --------------------------------------------------
# Repositories (NO dnf config-manager)
# --------------------------------------------------
RUN printf "[openshift-mirror-beta]\n\
name=OpenShift Mirror Beta Repository\n\
baseurl=https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rpms/4.21-el9-beta/\n\
enabled=1\n\
gpgcheck=0\n\
skip_if_unavailable=1\n" \
> /etc/yum.repos.d/openshift.repo

# --------------------------------------------------
# Install ALL required tools in ONE go
# --------------------------------------------------
RUN dnf install -y \
    curl \
    tar \
    createrepo_c \
    jq \
    skopeo \
    firewalld \
    containernetworking-plugins \
    policycoreutils \
 && dnf clean all

# --------------------------------------------------
# Download MicroShift RPMs and build local repo
# --------------------------------------------------
RUN set -eux; \
    mkdir -p /tmp/local-rpms; \
    curl -L --fail --retry 5 "${MICROSHIFT_RPM_URL}" -o /tmp/microshift-rpms.tgz; \
    tar -xzf /tmp/microshift-rpms.tgz -C /tmp/local-rpms; \
    createrepo_c /tmp/local-rpms; \
    printf "[microshift-local]\n\
name=MicroShift Local\n\
baseurl=file:///tmp/local-rpms\n\
enabled=1\n\
gpgcheck=0\n" > /etc/yum.repos.d/microshift-local.repo

# --------------------------------------------------
# Install MicroShift stack (single DNF transaction)
# --------------------------------------------------
RUN dnf install -y --nogpgcheck \
    microshift \
    microshift-kindnet \
    microshift-networking \
    microshift-topolvm \
    microshift-olm \
    microshift-selinux \
 && dnf clean all \
 && rm -rf /tmp/local-rpms /tmp/microshift-rpms.tgz \
 && rm -f /etc/yum.repos.d/microshift-local.repo

# --------------------------------------------------
# Copy assets (grouped for cache efficiency)
# --------------------------------------------------
RUN mkdir -p /etc/cni/net.d \
             /etc/microshift/manifests.d/001-test-app \
             /usr/local/bin \
             /usr/libexec/cni

COPY assets/13-microshift-kindnet.conf /etc/crio/crio.conf.d/
COPY assets/10-kindnet.conflist /etc/cni/net.d/
COPY assets/99-offline.conf /etc/containers/registries.conf.d/

COPY scripts/setup.sh /usr/local/bin/setup-storage.sh
COPY scripts/embed_image.sh /usr/local/bin/embed_image.sh
COPY scripts/copy_embed.sh /usr/local/bin/copy_embed.sh

COPY manifests/ /etc/microshift/manifests.d/001-test-app/
COPY image-list.txt /tmp/image-list.txt

COPY assets/fix-network.sh /usr/bin/fix-network.sh
COPY assets/fix-network.service /etc/systemd/system/

# --------------------------------------------------
# Permissions + embedding (minimal restorecon)
# --------------------------------------------------
RUN chmod +x /usr/local/bin/*.sh /usr/bin/fix-network.sh && \
    chmod 644 /etc/systemd/system/*.service || true

RUN /usr/local/bin/embed_image.sh /tmp/image-list.txt

RUN restorecon -v /usr/local/bin/* \
               /usr/bin/fix-network.sh \
               /etc/systemd/system/* \
               /etc/microshift/manifests.d/001-test-app/*

# --------------------------------------------------
# Firewall + user + systemd units (combined)
# --------------------------------------------------
RUN firewall-offline-cmd --zone=public --add-port=22/tcp \
 && firewall-offline-cmd --zone=public --add-port=80/tcp \
 && firewall-offline-cmd --zone=public --add-port=443/tcp \
 && firewall-offline-cmd --zone=public --add-port=6443/tcp \
 && firewall-offline-cmd --zone=public --add-port=30000-32767/tcp \
 && firewall-offline-cmd --zone=trusted --add-source=10.42.0.0/16 \
 && firewall-offline-cmd --zone=trusted --add-source=169.254.169.1 \
 && useradd -m -d /var/home/centos -G wheel centos \
 && echo "centos:bootc" | chpasswd

# --------------------------------------------------
# Systemd services
# --------------------------------------------------
COPY scripts/microshift-embed.service /usr/lib/systemd/system/

RUN printf "[Unit]\nDescription=Setup Storage\nBefore=microshift.service\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/setup-storage.sh\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n" \
    > /etc/systemd/system/microshift-storage-setup.service

RUN printf "[Unit]\nDescription=Make root filesystem shared\nBefore=microshift.service\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/mount --make-rshared /\n\n[Install]\nWantedBy=multi-user.target\n" \
    > /usr/lib/systemd/system/microshift-make-rshared.service

# --------------------------------------------------
# Final cleanup + enable services
# --------------------------------------------------
RUN rm -rf /usr/lib/microshift/manifests/microshift-olm && \
    systemctl enable \
      firewalld \
      microshift-make-rshared.service \
      microshift-embed.service \
      microshift-storage-setup.service \
      fix-network.service \
      microshift.service
====

[NOTE]
====
You do **not** need to modify `Containerfile` in this lab — it is provided so you understand what goes into your base appliance.
====

[#physically_bound]
== 2.2 Know: Physically-Bound Images for Disconnected Operations

=== Why `/usr` — Not `/var`?
[cols="1,2a", options="header"]
|===
| Directory | Strategy in bootc
| `/usr` | **Immutable:** Versioned with the OS. Apps here upgrade/rollback with the kernel.
| `/var` | **Mutable:** Runtime storage. Data here persists across OS updates.
|===



=== How Physical Embedding Works

Physical embedding means the app images are stored inside the OS image, so MicroShift can run without pulling from a registry.

* **Build time:** Use `skopeo` to copy container images into the immutable `/usr/lib` directory.
* **Runtime:** On boot, those images are imported into the local container store automatically.

**Helper Scripts Provided:**

* `embed_image.sh`: Pulls specified container images and their digests into the OS image during the build process.

[source,bash]
----
RUN skopeo copy --preserve-digests docker://${image} \
    dir:/usr/lib/containers/storage/${sha}
----

* `copy_embedded_images.sh`: Triggered at boot, this script populates the runtime container store from the immutable `/usr/lib` cache, making images "already present" for MicroShift.

[source,bash]
----
/usr/bin/skopeo copy --preserve-digests \
  dir:/usr/lib/containers/storage/${sha} \
  containers-storage:${image}
----

Upstream reference patterns: link:https://gitlab.com/fedora/bootc/examples/-/tree/main/physically-bound-images[Fedora examples^].


== 2.3 Show: Build the Self-Contained Appliance (CentOS 9)
We now embed a simple nginx web appliance to solve the **disconnected operations challenge**.


. Build the bootc image with CentOS 9 as the base with embedded appliance (~10–15 minutes):
+
[source,sh,role=execute]
----
time sudo podman build -t microshift-offline:c9 .
----


    This creates a container image containing:

    - CentOS Stream 9 base OS
    - MicroShift 4.21
    - All required container images embedded
    - Pre-configured services and networking

. Generate Bootable QCOW2 Image
+
Use bootc-image-builder to create a bootable disk image:
+
[source,sh,role=execute]
----
time sudo podman run --rm -it --privileged \
  -v $(pwd)/output:/output \
  -v /var/lib/containers/storage:/var/lib/containers/storage \
  quay.io/centos-bootc/bootc-image-builder:latest \
  --type qcow2 localhost/microshift-offline:c9
----
+
This generates a QCOW2 disk image in `./output/qcow2/disk.qcow2` that can be booted directly.

[#validation]
== 2.5 Validation: Success Criteria

[cols="1,3", options="header"]
|===
| Component | Expected Status
| **Base Image** | `quay.io/centos-bootc/centos-bootc:stream9` exists in podman.
| **Appliance Image** | `microshift-offline:c9` exists in podman.
| **Bootable qcow2** | `microshift-workshop-4.21.qcow2` is created.
|===

[source,sh,role=execute]
----
sudo podman images | grep microshift
ls -lh ./output/qcow2/disk.qcow2
----

---
**Next:** Proceed to xref:module-03.adoc[Module 3: Deploying to Edge Locations].
