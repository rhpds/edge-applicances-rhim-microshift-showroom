= Building Self-Contained Edge Appliances with RHEL Image Mode & MicroShift

Welcome to a hands-on lab focused on building real cloud-native appliances—designed for engineers, architects, consultants, and sales teams who build, sell, position, or operate solutions at the edge.

Our previous lab, link:https://rhpds.github.io/showroom-lb1054-rhel-image-mode/modules/index.html[LB1054 – Unleashing The Power of Image Mode for RHEL^], introduced treating the OS as an image.  
This lab takes the next step: **building a production-grade appliance** that addresses real customer challenges such as disconnected operations, risky updates, inconsistent lifecycle management, and resource-limited deployments.

[#customer_scenario]
== Customer Scenario: ManufacturingCo's Edge Appliance Challenge

ManufacturingCo operates 50 factory locations across North America, each running critical edge appliances that control production lines and quality monitoring systems.

These appliances must:

* Operate reliably in harsh industrial environments
* Function in disconnected or bandwidth-constrained networks
* Support cloud-native applications for modern workloads
* Update safely without disrupting production
* Maintain consistency across all 50 locations

=== Current State

* *Deployment cycles:* 6–8 weeks per location
* *Update failures:* ~15% require on-site IT intervention
* *Configuration drift:* ~30% diverge from their intended state within 6 months
* *Recovery time:* 2–4 hours for failed updates
* *Security patches:* Applied inconsistently due to limited or no connectivity

image::ManufacturingCo-challenges.jpg[ManufacturingCo-challenges.jpg,100%,100%]

=== The Challenge

ManufacturingCo needs a repeatable way to build, deploy, update, and operate self-contained edge appliances—without depending on network connectivity or highly skilled IT staff at each field site.

[NOTE]
====
**Metrics Source:** These values (deployment cycles, failure rates, configuration drift, etc.) reflect common industry patterns and are used here for illustration.  
When presenting to real customers, adjust these metrics to match their business, environment, and benchmarks.
====

[#problem]
== The Problem: Edge Appliances Are Hard to Operate at Scale

If you build or manage appliances in the field—especially across remote or disconnected sites—you face recurring challenges that slow delivery, increase cost, and put reliability at risk.

=== Configuration Drift

==== The Pain
Systems gradually change from the intended state—especially without expert hands on site.

==== The Impact
* Fleet becomes inconsistent and unpredictable
* Patch gaps create vulnerabilities
* Troubleshooting is slow and error-prone
* Compliance and audit checks become harder

=== Risky Updates

==== The Pain
Traditional in-place updates can break systems and are difficult to recover from remotely.

==== The Impact
* Outages or degraded services during failed updates
* Costly “truck rolls” for onsite recovery
* Higher risk of corruption or service disruption
* Rollbacks are slow—or impossible

=== Disconnected Operations

==== The Pain
Many edge sites lack reliable connectivity—or any connection at all.

==== The Impact
* Systems cannot pull images or packages on demand
* Security and feature updates get delayed
* USB / sneakernet workflows become the norm
* This slows down scale and standardization

=== Resource Constraints

==== The Pain
Edge hardware is small, rugged, and cost-sensitive.

==== The Impact
* Typical footprint: 2 CPU + 2 GB RAM
* Resource-heavy platforms don’t fit
* Full Kubernetes clusters overwhelm devices
* Higher hardware costs if footprint isn’t optimized

=== Lifecycle Management Complexity

==== The Pain
Managing dozens—or hundreds—of edge sites multiplies every operational issue.

==== The Impact
* Slow deployment cycles across locations
* Version sprawl across OS and applications
* Build and config inconsistency between sites
* Fleet operations become manual and reactive

[#solution]
== The Solution: RHEL Image Mode + MicroShift

**RHEL Image Mode**, powered by `bootc`, eliminates many of these operational risks by treating the *entire* OS as a **versioned, immutable container image**.

Paired with **Red Hat build of MicroShift**, you get a lightweight Kubernetes platform that delivers a consistent, cloud-native experience on small-footprint edge devices.

Together, they create a **self-contained, reliable edge appliance platform**.

=== How It Solves Configuration Drift

==== The Solution
Every system boots from the same golden image that contains OS + apps.

==== The Outcome
* Consistent behavior across sites
* Easier troubleshooting
* Predictable compliance

=== How It Solves Risky Updates

==== The Solution
Atomic updates with A/B boot and instant rollback.

==== The Outcome
* Safe upgrades with fast recovery
* No need for on-site IT support
* Greatly reduced outage risk

=== How It Solves Disconnected Operations

==== The Solution
Embed OS, MicroShift, and applications directly into the bootable image—no network required.

==== The Outcome
* Works fully offline
* Deploy via USB/ISO or sneakernet
* No runtime registry dependency

=== How It Solves Resource Constraints

==== The Solution
MicroShift provides Kubernetes derived from OpenShift—optimized for tiny edge systems.

==== The Outcome
* Runs cloud-native apps on minimal hardware
* Delivers enterprise-grade workload orchestration
* Maintains OpenShift compatibility

=== How It Solves Lifecycle Management

==== The Solution
Build, test, ship, and manage appliances using standard container workflows.

==== The Outcome
* Days instead of weeks for updates
* Git-like versioning for the full stack
* Simple fleet-wide lifecycle control

image::use-cases.jpg[use-cases,100%,100%]

[NOTE]
====
Image Mode evolved from link:https://www.redhat.com/en/blog/red-hat-device-edge-rpm-ostree-updates[rpm-ostree^], a proven architecture for edge and appliance operations.  
This lab builds on link:https://rhpds.github.io/showroom-lb1054-rhel-image-mode/modules/index.html[LB1054 – Unleashing The Power of Image Mode for RHEL^], extending it to embed MicroShift and applications into the OS image—creating fully self-contained appliances that function even in disconnected environments.
====

[#benefits]
== Benefits to the Customer

By adopting RHEL Image Mode and MicroShift for edge appliances, customers achieve:

[cols="20,25,25,30", options="header"]
|===
| Benefit | From | To | Impact

| Accelerate Time-to-Market
| 6–8 week deployment cycles per location
| Days to deploy new appliances or updates
| **Reduce time-to-value by 75%, enable faster innovation cycles**

| Simplify Appliance Creation
| Complex multi-step build processes, manual configuration
| Single Containerfile defines entire appliance
| **Reduce build complexity by 80%, enable version control for entire stack**

| Streamline Field Operations
| Risky updates requiring on-site IT, 15% failure rate
| Atomic updates with instant rollback, smartphone-like reliability
| **Eliminate 90% of update-related downtime, reduce field support costs**

| Enhance Security
| Configuration drift, inconsistent patching, security vulnerabilities
| Immutable images, embedded security patches, reduced attack surface
| **Eliminate configuration drift, ensure consistent security posture**

| Enable Disconnected Deployments
| Network-dependent updates, manual processes for offline locations
| Self-contained images, USB/ISO deployment, no runtime registry dependency
| **Deploy to any location regardless of connectivity, reduce operational complexity**

| Manage Fleets at Scale
| Inconsistent versions, difficult fleet management
| Standard container registries, Git-like versioning for OS
| **Consistent versions across fleet, simplified lifecycle management**
|===
[#common_questions]
== Common Customer Questions

[.text-left]
**Q:** "How does this work with our existing container registries and CI/CD pipelines?" +
**A:** RHEL Image Mode uses standard container registries (Quay.io, Artifact Registry, etc.) and integrates with existing CI/CD tools. You build bootc images just like any container image. +
*Show:* Module 2 demonstrates building images with standard tools.

[.text-left]
**Q:** "What about compliance and security in disconnected environments?" +
**A:** Immutable images eliminate configuration drift, and security patches are embedded directly in images. You can maintain compliance even in air-gapped environments. +
*Show:* Module 3 verifies embedded images and Module 4 demonstrates secure disconnected updates.

[.text-left]
**Q:** "How complex is the implementation compared to our current approach?" +
**A:** The Containerfile approach is simpler than traditional kickstart + manual configuration. You define everything in one file, build once, deploy everywhere. +
*Show:* Module 2 shows the Containerfile structure—it's straightforward.

[.text-left]
**Q:** "What's the business impact timeline? How quickly can we see results?" +
**A:** Initial appliance build takes hours (not weeks). Updates can be deployed in minutes with instant rollback. Most customers see 50-75% reduction in deployment time within the first quarter. +
*Show:* Module 4 demonstrates atomic updates in action.

[.text-left]
**Q:** "Can we still customize the OS and applications for different use cases?" +
**A:** Yes, you build different Containerfiles for different use cases. The base OS is consistent, but you can layer on application-specific components. +
*Show:* Module 2 shows how 4.19 extends the base image.

[.text-left]
**Q:** "What happens if an update fails in production?" +
**A:** RHEL Image Mode uses A/B boot—the new version is staged but doesn't activate until reboot. If something goes wrong, you roll back instantly to the previous working state. +
*Show:* Module 4 demonstrates rollback capabilities.

[.text-left]
**Q:** "How do we manage updates across hundreds of edge locations?" +
**A:** Use standard container registries and tags. You can push a new image version, and each location can pull and apply it independently. For disconnected locations, export images to directories and transfer via USB/network. +
*Show:* Module 4 shows disconnected update workflow.

[#what_you_will_learn]
== What You Will Learn

By completing this lab, you'll be able to demonstrate to customers how to:

* **Build** self-contained edge appliances that solve configuration drift and lifecycle management challenges
* **Embed** cloud-native applications directly into OS images, enabling disconnected deployments
* **Deploy** appliances consistently across diverse locations using standard container workflows
* **Update** appliances safely with atomic updates and instant rollback, eliminating risky field updates

Each module connects technical capabilities to the customer pain points we discussed above.

[#lab_access]
== Lab Access

The terminal window to your right is *already* logged into the lab environment. All steps of this lab are to be completed in this terminal.

To begin, please proceed to the first module.