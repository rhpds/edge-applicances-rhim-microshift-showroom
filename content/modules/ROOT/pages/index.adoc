= Building Self-contained Appliances with RHEL Image Mode and MicroShift

Welcome to a hands-on lab focused on the modern appliance experience.

Our link:https://rhpds.github.io/showroom-lb1054-rhel-image-mode/modules/index.html[LB1054 - Unleashing The Power of Image Mode for RHEL] lab introduced the foundational technology to treat the OS as an image. 

That lab introduced the technology, but it's important to understand the primary use cases. RHEL Image Mode evolved from technologies like link:https://www.redhat.com/en/blog/red-hat-device-edge-rpm-ostree-updates[rpm-ostree], making it a natural fit for appliances, edge devices, and container hosts where image-based operations are already common.

The goal of Image Mode is to bring these benefits to general-purpose RHEL. It excels in scenarios that require tightly coupling an application and its OS as a single, version-controlled package. For example, modern AI/ML workloads often have strict dependencies on specific firmware and driver versions, making an image-based approach ideal for ensuring consistency.

image::use-cases.jpg[use-cases,100%,100%]

This lab takes the next logical step: building a true cloud-native appliance.

If you build or manage software appliances—especially for edge or disconnected environments—you face constant challenges: 

image::challenges.jpg[challenges,100%,100%]

== How RHEL Image Mode Transforms Edge Appliances

RHEL Image Mode addresses OS-level challenges for edge appliances by treating the entire OS as an immutable, versioned image. By treating your entire appliance as a bootable container image, you can fundamentally change your development and operations:

=== Technical Capabilities

* **Immutable, Versioned Images:** The entire OS is versioned and deployed as a single unit, eliminating configuration drift and ensuring consistency across all devices.

* **Atomic Updates with Rollbacks:** System updates occur as complete image replacements using an A/B boot model, providing fast recoveries in case of unforeseen issues and increased reliability over the life of the system.

* **Registry-Based Management:** Control OS and application container versioning through industry-standard registries and tags, enabling updates at scale.

* **Multiple Deployment Methods:** Supports connected, air-gapped, and ISO-based deployments, enabling reliable operations even when registries are unavailable.

These OS-level solutions are excellent, but they become even more complex when your goal is to run cloud-native applications. How do you provide a consistent Kubernetes experience for teams, but on hardware that is space-constrained, low-power, or offline?

This is where link:https://www.redhat.com/en/topics/edge-computing/microshift[Red Hat build of MicroShift] comes in. It is a lightweight Kubernetes distribution derived from link:https://www.redhat.com/en/technologies/cloud-computing/openshift/edge-computing[Red Hat® OpenShift®], designed specifically for these exact edge and small-footprint appliance use cases. It provides a consistent, enterprise-grade Kubernetes platform without the overhead of a full cluster.

This lab leverage what we learned about Image Mode through link:https://rhpds.github.io/showroom-lb1054-rhel-image-mode/modules/index.html[LB1054 - Unleashing The Power of Image Mode for RHEL], and moves beyond with focus for **Edge Appliances**. You will learn how to build a true, self-contained appliance by embedding Red Hat build of MicroShift and your applications directly into the OS image—using "physically-bound images" to create an appliance ready **for disconnected edge deployments**.

=== Business Value

* **Accelerate Time-to-Market:** Use standard DevOps/CI/CD practices for the *entire* OS and application stack, dramatically speeding up development and delivery.

* **Simplify Appliance Creation:** Combine the OS, drivers, and your applications into a single, manageable unit.

* **Streamline Field Operations:** Deliver "smartphone-like" reliability with fast, safe rollbacks and predictable system behavior.

* **Enable Disconnected Deployments:** Ship truly self-contained, "physically-bound" images for air-gapped or offline environments by embedding application containers directly into the OS image.

* **Enhance Security:** Radically reduce your appliance's attack surface and eliminate configuration drift with immutable system images.

* **Manage Fleets at Scale:** Control OS and application versions consistently using standard container registries and tags.

== What you will learn

Upon completion of this lab, you will be able to:

* **Build** a self-contained appliance using RHEL Image Mode (bootc).
* **Embed** cloud-native applications (via MicroShift) directly into the bootable OS image for disconnected scenarios.
* **Generate** a bootable ISO from a container image and deploy it to a KVM virtual machine.
* **Perform** an atomic, image-based system upgrade and rollback on a live, running appliance.

== Lab Access

The terminal window to your right is *already* logged into the lab environment. All steps of this lab are to be completed in this terminal.

To begin, please proceed to the first module.
