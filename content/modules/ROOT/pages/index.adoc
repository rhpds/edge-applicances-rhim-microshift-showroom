= Building self-contained edge appliances with Bootc & MicroShift

Welcome to a hands-on lab that shows how to build a real edge appliance. It is written for mixed audiences, including people who are new to bootc or MicroShift.

This lab takes the next step: **building a working appliance** that handles common edge problems like poor connectivity, risky updates, inconsistent system state, and limited hardware resources.


[#problem]
== The challenge: Edge appliances are hard to operate at scale

Consider ManufacturingCo, which operates 50 factory locations across North America, each running critical edge appliances that control production lines and quality monitoring systems. These appliances must operate reliably in harsh industrial environments, function in disconnected or bandwidth-constrained networks, support cloud-native applications, update safely without disrupting production, and maintain consistency across all locations.

=== The Reality

ManufacturingCo's current state illustrates the challenges many organizations face:

* *Deployment cycles:* 6–8 weeks per location
* *Update failures:* ~15% require on-site IT intervention
* *Configuration drift:* ~30% diverge from their intended state within 6 months
* *Recovery time:* 2–4 hours for failed updates
* *Security patches:* Applied inconsistently due to limited or no connectivity

image::ManufacturingCo-challenges.jpg[ManufacturingCo challenges,100%,100%]

[NOTE]
====
**Metrics Source:** These values (deployment cycles, failure rates, configuration drift, etc.) reflect common industry patterns and are used here for illustration.
When presenting to real customers, adjust these metrics to match their business, environment, and benchmarks.
====

=== Common Edge Challenges

If you build or manage appliances in the field—especially across remote or disconnected sites—you face recurring challenges that slow delivery, increase cost, and put reliability at risk:

* **Configuration drift** — Systems gradually change from intended state, creating inconsistencies
* **Risky updates** — Traditional in-place updates can break systems and are difficult to recover from remotely
* **Disconnected operations** — Many edge sites lack reliable connectivity, preventing on-demand updates
* **Resource constraints** — Edge hardware is small, rugged, and cost-sensitive (typically 2 CPU + 2 GB RAM)
* **Lifecycle management complexity** — Managing dozens or hundreds of edge sites multiplies every operational issue

ManufacturingCo needs a repeatable way to build, deploy, update, and operate self-contained edge appliances—without depending on network connectivity or highly skilled IT staff at each field site. This challenge is common across edge deployments.

For detailed explanations of these challenges, see xref:module-01.adoc#edge_challenges[Module 1: Understanding Edge Appliance Challenges].

[#solution]
== The solution: bootc + MicroShift

**bootc** delivers the *entire* OS as a **versioned container image**. Updates replace the whole OS image instead of changing files in place.

**MicroShift** is a smaller Kubernetes that runs well on edge devices. Together, bootc + MicroShift give you a consistent way to run apps on small hardware.

Together, they create a **self-contained, reliable edge appliance platform** that addresses the core challenges:

* **Configuration drift** → Reduced because systems come from the same versioned image
* **Risky updates** → Safer with A/B boot (two slots) and quick rollback
* **Disconnected operations** → Works offline by embedding OS, MicroShift, and apps in the image
* **Resource constraints** → Addressed with MicroShift, which is lightweight for small devices
* **Lifecycle management** → Simpler versioning and repeatable builds

For detailed explanations of how bootc addresses these challenges, see xref:module-01.adoc#bootc_solution[Module 1: How bootc Addresses These Challenges].

image::bootc-solution.png[bootc image-based workflow,100%,100%]

[NOTE]
====
bootc builds on the rpm-ostree heritage for image-based OS delivery, a proven architecture for edge and appliance operations.
This lab extends that approach to embed MicroShift and applications into the OS image—creating fully self-contained appliances that function even in disconnected environments.
====

[#benefits]
== Benefits to the customer

By adopting bootc and MicroShift for edge appliances, customers achieve:

[cols="20,25,25,30", options="header"]
|===
| Benefit | From | To | Impact

| Accelerate Time-to-Market
| 6–8 week deployment cycles per location
| Days to build and deploy new appliances or updates
| **Reduce time-to-value, enable faster innovation cycles**

| Simplify Appliance Creation
| Complex multi-step build processes, manual configuration
| Single Containerfile defines entire appliance
| **Reduce build complexity, enable version control for entire stack**

| Streamline Field Operations
| Risky updates requiring on-site IT, 15% failure rate
| Atomic updates with instant rollback, smartphone-like reliability
| **Eliminate update-related downtime, reduce field support costs**

| Enhance Security
| Configuration drift, inconsistent patching, security vulnerabilities
| Immutable images, embedded security patches, reduced attack surface
| **Eliminate configuration drift, ensure consistent security posture**

| Enable Disconnected Deployments
| Network-dependent updates, manual processes for offline locations
| Self-contained images, USB/ISO deployment, no runtime registry dependency
| **Deploy to any location regardless of connectivity, reduce operational complexity**

| Manage Fleets at Scale
| Inconsistent versions, difficult fleet management
| Standard container registries, Git-like versioning for OS
| **Consistent versions across fleet, simplified lifecycle management**
|===
[#common_questions]
== Common customer questions

[.text-left]
**Q:** "How does this work with our existing container registries and CI/CD pipelines?" +
**A:** bootc uses standard container registries (Quay.io, Artifact Registry, etc.) and integrates with existing CI/CD tools. You build bootc images just like any container image. +
*Show:* Module 2 demonstrates building images with standard tools.

[.text-left]
**Q:** "What about compliance and security in disconnected environments?" +
**A:** Immutable images eliminate configuration drift, and security patches are embedded directly in images. You can maintain compliance even in air-gapped environments. +
*Show:* Module 3 verifies embedded images and Module 4 demonstrates secure disconnected updates.

[.text-left]
**Q:** "How complex is the implementation compared to our current approach?" +
**A:** The Containerfile approach is simpler than traditional kickstart + manual configuration. You define everything in one file, build once, deploy everywhere. +
*Show:* Module 2 shows the Containerfile structure—it's straightforward.

[.text-left]
**Q:** "Can we still customize the OS and applications for different use cases?" +
**A:** Yes, you build different Containerfiles for different use cases. The base OS is consistent, but you can layer on application-specific components. +
*Show:* Module 2 shows how 4.19 extends the base image.

[.text-left]
**Q:** "What happens if an update fails in production?" +
**A:** bootc uses A/B boot—the new version is staged but doesn't activate until reboot. If something goes wrong, you roll back instantly to the previous working state. +
*Show:* Module 4 demonstrates rollback capabilities.

[.text-left]
**Q:** "How do we manage updates across hundreds of edge locations?" +
**A:** Use standard container registries and tags. You can push a new image version, and each location can pull and apply it independently. For disconnected locations, export images to directories and transfer via USB/network. +
*Show:* Module 4 shows disconnected update workflow.

[#what_you_will_learn]
== What you will learn

By completing this lab, you'll be able to demonstrate to customers how to:

* **Build** self-contained edge appliances that solve configuration drift and lifecycle management challenges
* **Embed** cloud-native applications directly into OS images, enabling disconnected deployments
* **Deploy** appliances consistently across diverse locations using standard container workflows
* **Update** appliances safely with atomic updates and instant rollback, eliminating risky field updates

Each module connects technical capabilities to the customer pain points we discussed above.

[#lab_access]
== Lab access

The terminal window to your right is *already* logged into the lab environment. All steps of this lab are to be completed in this terminal.

To begin, please proceed to the first module.
