= Building Self-Contained Edge Appliances with RHEL Image Mode & MicroShift

Welcome to a hands-on lab focused on building real cloud-native appliances—designed for engineers, architects, consultants, and sales teams who build, sell, position, or operate solutions at the edge.

Our previous lab, link:https://rhpds.github.io/showroom-lb1054-rhel-image-mode/modules/index.html[LB1054 – Unleashing The Power of Image Mode for RHEL^], introduced treating the OS as an image.  
This lab takes the next step: **building a production-grade appliance** that addresses real customer challenges such as disconnected operations, risky updates, inconsistent lifecycle management, and resource-limited deployments.

[#problem]
== The challenge: Edge appliances are hard to operate at scale

Consider ManufacturingCo, which operates 50 factory locations across North America, each running critical edge appliances that control production lines and quality monitoring systems. These appliances must operate reliably in harsh industrial environments, function in disconnected or bandwidth-constrained networks, support cloud-native applications, update safely without disrupting production, and maintain consistency across all locations.

=== The Reality

ManufacturingCo's current state illustrates the challenges many organizations face:

* *Deployment cycles:* 6–8 weeks per location
* *Update failures:* ~15% require on-site IT intervention
* *Configuration drift:* ~30% diverge from their intended state within 6 months
* *Recovery time:* 2–4 hours for failed updates
* *Security patches:* Applied inconsistently due to limited or no connectivity

image::ManufacturingCo-challenges.jpg[ManufacturingCo challenges,100%,100%]

[NOTE]
====
**Metrics Source:** These values (deployment cycles, failure rates, configuration drift, etc.) reflect common industry patterns and are used here for illustration.  
When presenting to real customers, adjust these metrics to match their business, environment, and benchmarks.
====

=== Common Edge Challenges

If you build or manage appliances in the field—especially across remote or disconnected sites—you face recurring challenges that slow delivery, increase cost, and put reliability at risk:

* **Configuration drift** — Systems gradually change from intended state, creating inconsistencies
* **Risky updates** — Traditional in-place updates can break systems and are difficult to recover from remotely
* **Disconnected operations** — Many edge sites lack reliable connectivity, preventing on-demand updates
* **Resource constraints** — Edge hardware is small, rugged, and cost-sensitive (typically 2 CPU + 2 GB RAM)
* **Lifecycle management complexity** — Managing dozens or hundreds of edge sites multiplies every operational issue

ManufacturingCo needs a repeatable way to build, deploy, update, and operate self-contained edge appliances—without depending on network connectivity or highly skilled IT staff at each field site. This challenge is common across edge deployments.

For detailed explanations of these challenges, see xref:module-01.adoc#edge_challenges[Module 1: Understanding Edge Appliance Challenges].

[#solution]
== The solution: RHEL Image Mode + MicroShift

**RHEL Image Mode**, powered by `bootc`, eliminates many of these operational risks by treating the *entire* OS as a **versioned, immutable container image**.

Paired with **Red Hat build of MicroShift**, you get a lightweight Kubernetes platform that delivers a consistent, cloud-native experience on small-footprint edge devices.

Together, they create a **self-contained, reliable edge appliance platform** that addresses the core challenges:

* **Configuration drift** → Eliminated through immutable, versioned images
* **Risky updates** → Solved with atomic A/B boot and instant rollback
* **Disconnected operations** → Enabled by embedding OS, MicroShift, and applications directly into bootable images
* **Resource constraints** → Addressed with MicroShift, a lightweight Kubernetes platform optimized for small-footprint devices
* **Lifecycle management** → Simplified through standard container workflows and Git-like versioning

For detailed explanations of how RHEL Image Mode addresses these challenges, see xref:module-01.adoc#bootc_solution[Module 1: How RHEL Image Mode Addresses These Challenges].

[NOTE]
====
Image Mode evolved from link:https://www.redhat.com/en/blog/red-hat-device-edge-rpm-ostree-updates[rpm-ostree^], a proven architecture for edge and appliance operations.  
This lab builds on link:https://rhpds.github.io/showroom-lb1054-rhel-image-mode/modules/index.html[LB1054 – Unleashing The Power of Image Mode for RHEL^], extending it to embed MicroShift and applications into the OS image—creating fully self-contained appliances that function even in disconnected environments.
====

[#benefits]
== Benefits to the customer

By adopting RHEL Image Mode and MicroShift for edge appliances, customers achieve:

[cols="20,25,25,30", options="header"]
|===
| Benefit | From | To | Impact

| Accelerate Time-to-Market
| 6–8 week deployment cycles per location
| Days to build and deploy new appliances or updates
| **Reduce time-to-value, enable faster innovation cycles**

| Simplify Appliance Creation
| Complex multi-step build processes, manual configuration
| Single Containerfile defines entire appliance
| **Reduce build complexity, enable version control for entire stack**

| Streamline Field Operations
| Risky updates requiring on-site IT, 15% failure rate
| Atomic updates with instant rollback, smartphone-like reliability
| **Eliminate dramatically update-related downtime, reduce field support costs**

| Enhance Security
| Configuration drift, inconsistent patching, security vulnerabilities
| Immutable images, embedded security patches, reduced attack surface
| **Eliminate configuration drift, ensure consistent security posture**

| Enable Disconnected Deployments
| Network-dependent updates, manual processes for offline locations
| Self-contained images, USB/ISO deployment, no runtime registry dependency
| **Deploy to any location regardless of connectivity, reduce operational complexity**

| Manage Fleets at Scale
| Inconsistent versions, difficult fleet management
| Standard container registries, Git-like versioning for OS
| **Consistent versions across fleet, simplified lifecycle management**
|===
[#common_questions]
== Common customer questions

[.text-left]
**Q:** "How does this work with our existing container registries and CI/CD pipelines?" +
**A:** RHEL Image Mode uses standard container registries (Quay.io, Artifact Registry, etc.) and integrates with existing CI/CD tools. You build bootc images just like any container image. +
*Show:* Module 2 demonstrates building images with standard tools.

[.text-left]
**Q:** "What about compliance and security in disconnected environments?" +
**A:** Immutable images eliminate configuration drift, and security patches are embedded directly in images. You can maintain compliance even in air-gapped environments. +
*Show:* Module 3 verifies embedded images and Module 4 demonstrates secure disconnected updates.

[.text-left]
**Q:** "How complex is the implementation compared to our current approach?" +
**A:** The Containerfile approach is simpler than traditional kickstart + manual configuration. You define everything in one file, build once, deploy everywhere. +
*Show:* Module 2 shows the Containerfile structure—it's straightforward.

[.text-left]
**Q:** "Can we still customize the OS and applications for different use cases?" +
**A:** Yes, you build different Containerfiles for different use cases. The base OS is consistent, but you can layer on application-specific components. +
*Show:* Module 2 shows how 4.19 extends the base image.

[.text-left]
**Q:** "What happens if an update fails in production?" +
**A:** RHEL Image Mode uses A/B boot—the new version is staged but doesn't activate until reboot. If something goes wrong, you roll back instantly to the previous working state. +
*Show:* Module 4 demonstrates rollback capabilities.

[.text-left]
**Q:** "How do we manage updates across hundreds of edge locations?" +
**A:** Use standard container registries and tags. You can push a new image version, and each location can pull and apply it independently. For disconnected locations, export images to directories and transfer via USB/network. +
*Show:* Module 4 shows disconnected update workflow.

[#what_you_will_learn]
== What you will learn

By completing this lab, you'll be able to demonstrate to customers how to:

* **Build** self-contained edge appliances that solve configuration drift and lifecycle management challenges
* **Embed** cloud-native applications directly into OS images, enabling disconnected deployments
* **Deploy** appliances consistently across diverse locations using standard container workflows
* **Update** appliances safely with atomic updates and instant rollback, eliminating risky field updates

Each module connects technical capabilities to the customer pain points we discussed above.

[#lab_access]
== Lab access

The terminal window to your right is *already* logged into the lab environment. All steps of this lab are to be completed in this terminal.

To begin, please proceed to the first module.