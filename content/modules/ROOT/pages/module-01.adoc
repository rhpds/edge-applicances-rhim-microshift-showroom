= Module 1: Foundation – Understanding edge challenges and preparing the lab
:page-nav-title: Edge Foundation
:icons: font
:source-highlighter: rouge
:experimental:

== Learning objectives
By the end of this module, you will be able to:

* Identify key edge computing challenges and how bootc addresses them
* Explain what bootc is and how it delivers atomic, image-based updates
* Understand MicroShift as a lightweight Kubernetes for edge devices
* Explain the build → deploy → manage workflow for bootc-based appliances
* Navigate the lab environment and recognize the key system components
* Understand how physically-bound images support disconnected deployments

[#know_section]
[#edge_challenges]
== 1.1 Know: Understanding Edge Appliance Challenges

=== The Business Challenge
Organizations running systems outside the data center face a shared reality: remote locations make systems harder to manage and keep consistent.

[cols="1,3", options="header"]
|===
| The Reality of Edge | The Resulting Friction
| **Remote Devices** | Highly skilled IT staff are rarely onsite for troubleshooting.
| **Spotty Connectivity** | Standard "always-on" cloud assumptions fail.
| **Limited Resources** | Physical and compute constraints limit traditional tooling.
|===

=== What is Edge Computing?
Edge computing means running systems **outside** the data center—like warehouses, factories, retail sites, hospitals, and power grids.

While the concept is decades old, today’s edge includes:

* **Containers and cloud-native apps**
* **Microservices and Kubernetes**
* **AI/ML inference at the edge**
* **Zero-touch provisioning**
* **Security as a first-class requirement**

This evolution increases capability—but also exposes limits of traditional OS deployment and lifecycle models.

=== The Constraints of Edge Environments
Edge environments must deal with constraints that are uncommon in data centers or the cloud:

[cols="1s,3", options="header"]
|===
| Constraint | Description
| Physical | Limited space, power, cooling, and difficult physical access.
| Network | Low bandwidth, unreliable links, isolated subnets, and non-standard DNS/DHCP.
| Security | Device tampering, lost hardware risk, secure onboarding, and supply chain integrity.
| Availability | High business impact from outages; difficult backup and restore.
| Organizational | Little to no onsite IT support; unclear ownership across app + OS lifecycle.
|===



=== Edge Topologies: No One Size Fits All
Edge deployments vary widely based on operational needs and lifecycle constraints:

* **Two-tier:** Far edge devices communicating directly with a central cloud.
* **Multi-tier:** Factory floor ↔ regional onsite hub ↔ centralized cloud.
* **Hardware:** Embedded systems, industrial gateways, IoT devices, and ruggedized compute.

=== Why Edge Appliances Are Hard to Manage
Inconsistent environments amplify the core challenges of appliance management:

* **Configuration drift:** Appliances gradually diverge from expected state leading to unpredictable behavior.
* **Risky updates:** In-place updates risk service loss, require expert recovery, and cause downtime.
* **Disconnected locations:** No registry access means manual updates and delayed security patches.
* **Resource constraints:** Minimal CPU/RAM limits what platform and tooling can run.
* **Lifecycle sprawl:** Building, deploying, patching, and tracking hundreds of edge systems becomes a full-time burden.

[NOTE]
====
**Industry Examples:**

* **Manufacturing:** quality monitoring systems facing long deployment cycles and update failure rates.
* **Telecom:** network edge appliances for 5G base stations requiring rapid deployment.
* **Energy:** industrial IoT gateways for remote oil & gas monitoring.
* **Healthcare:** medical device edge appliances ensuring consistent security patches.
====

[#bootc_solution]
== 1.2 Know: How bootc Addresses These Challenges

bootc **treats the OS like a container image**. Instead of changing a live system, it replaces the system image during updates.

[NOTE]
====
**Simple terms:** The OS is a single image. Updates swap the image, and rollback swaps back.
====

=== What is bootc?

bootc is an image-based Linux system that uses container tooling (like Podman) to build, distribute, and update the entire operating system. Key concepts:

* **Container-native OS:** The OS is built and shipped as an OCI container image
* **A/B Boot Slots:** Two system partitions allow atomic switching between versions
* **Immutable by default:** The base OS is read-only; changes go to `/etc` and `/var`
* **Familiar tooling:** Use `Containerfile`, `podman build`, and container registries

image::bootc-architecture.png[bootc with package mode,100%,100%]

=== What is MicroShift?

MicroShift is a lightweight Kubernetes distribution optimized for edge devices. It brings OpenShift APIs to resource-constrained environments.

* **Small footprint:** Runs on devices with as little as 2 CPU cores and 2 GB RAM
* **OpenShift APIs:** Compatible with OpenShift workloads and tooling
* **Self-contained:** All components run as a single binary
* **Edge-optimized:** Designed for disconnected, intermittent, or low-bandwidth networks

image::microshift-architecture.png[MicroShift architecture,100%,100%]

=== Lightweight Kubernetes Alternatives

If you're familiar with other lightweight Kubernetes distributions, MicroShift fits in the same category:

* **k3s** — Popular CNCF-certified lightweight Kubernetes from Rancher
* **k0s** — Zero-dependency Kubernetes from Mirantis
* **MicroK8s** — Snap-based lightweight Kubernetes from Canonical

MicroShift is Red Hat's approach to this space, designed specifically for edge devices with OpenShift API compatibility.

[NOTE]
====
**Why MicroShift for this workshop?**

* Integrates natively with bootc and the RHEL ecosystem
* OpenShift API compatibility means workloads move seamlessly between edge and data center
* The patterns shown here (embedded images, atomic updates) apply to any lightweight Kubernetes
====

=== Current State vs. Desired State
[cols="1a,1a", options="header"]
|===
| ❌ Traditional State | ✅ Desired State (bootc)
| 
* Manual or scripted OS build/config
* Drift grows with every patch
* Updates are risky/slow to recover
* Registry connectivity required
* Difficult version tracking
| 
* Immutable, versioned OS image
* Boots from a known-good source
* Atomic updates + Instant rollback
* Works online, offline, or air-gapped
* Predictable, repeatable builds
|===

[#workflow]
== 1.3 Know: The Build-Deploy-Manage Workflow

=== Technical Lifecycle Comparison
[cols="1,2a,2a", options="header"]
|===
| Phase | Traditional Appliance | bootc

| *Describe*
| Manual requirements or scattered scripts.
| A single, versioned `Containerfile`.

| *Build*
| Requires dedicated build servers.
| Standard tools: Podman/Docker.

| *Generate*
| Manual ISO creation tools.
| `bootc-image-builder` (ISO, AMI, QCOW2).

| *Deploy*
| Manual install or PXE booting.
| Same image for VM, Metal, or Edge.

| *Update*
| Incremental (drift-prone) patching.
| Atomic "A/B" image swap + Reboot (two slots: old and new).
|===



image::redhat-image-mode.png[bootc architecture diagram,100%,100%]

[NOTE]
====
This lab includes a ready-made WordPress + MySQL demo workload and MicroShift manifests. You’ll embed these directly into the OS image.
====

=== Lab Overview: Environment and Components
You will interact with 3 core systems:

1. **Container Build Host:** The primary system where you build bootc appliances and embed images using `podman`.
2. **Container Registry:** Hosts bootc images to demonstrate connected and on-demand updates.
3. **Target Host VM:** Represents a remote edge appliance where the bootc image is installed.

image::disconnected.png[disconnected-workflow,100%,100%]

=== Hands-On: Lab Files
All lab content has been pre-staged in your working directory.

[source,sh,role=execute]
----
cd ~/airgapped-bootc-embedded
ls -la
----

[%collapsible]
====
.Detailed File Overview
* `Containerfile`, `Containerfile.c10` – Image definitions.
* `assets/` – Appliance build scripts.
* `scripts/` – Scripts to embed images into build.
* `create-vm.sh`, `setup-isolated-network.sh` – VM and network provisioning.
* `wordpress/`, `manifests/` – Sample application manifests.
* `image-list.txt` – List of images required for MicroShift and appliances.

====

[#validation]
== 1.4 Validation: Environment Ready

=== Validate Your Environment
. **Confirm Directory:**
+
[source,sh,role=execute]
----
pwd
----
+
Expected: `/home/lab-user/airgapped-bootc-embedded`

. **Confirm Toolset:**
+
[source,sh,role=execute]
----
which podman skopeo
----

. **Confirm Source Files:**
+
[source,sh,role=execute]
----
ls -la Containerfile.*
----

[IMPORTANT]
====
**Validation Success:** Your environment is ready. You have access to Podman, all Containerfiles, and the necessary build scripts to proceed to Module 2.
====

